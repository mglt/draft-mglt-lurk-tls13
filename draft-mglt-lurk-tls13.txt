



LURK                                                          D. Migault
Internet-Draft                                                  Ericsson
Intended status: Standards Track                        14 February 2022
Expires: 18 August 2022


         LURK Extension version 1 for (D)TLS 1.3 Authentication
                        draft-mglt-lurk-tls13-05

Abstract

   This document defines a LURK extension for TLS 1.3 [RFC8446], with
   the specification of a Cryptographic Service (CS) for both the TLS
   client and the TLS server.

   TODO: * E provides the certificate, this makes unnecessary the need
   to specify the sig_algounless one certificate can have different
   signature schemes. * CS MUST check the certificate is supported by
   the client.  * There is no need to specify the certificate_contex in
   the Cert (finger_print) as it is known from the CertificateRequest
   for the client and has a fix value for the server.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 18 August 2022.

Copyright Notice

   Copyright (c) 2022 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights



Migault                  Expires 18 August 2022                 [Page 1]

Internet-Draft                LURK/TLS 1.3                 February 2022


   and restrictions with respect to this document.  Code Components
   extracted from this document must include Simplified BSD License text
   as described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Simplified BSD License.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
   2.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   4
   3.  LURK Header . . . . . . . . . . . . . . . . . . . . . . . . .   4
   4.  Structures  . . . . . . . . . . . . . . . . . . . . . . . . .   6
     4.1.  secret_request  . . . . . . . . . . . . . . . . . . . . .   6
     4.2.  handshake . . . . . . . . . . . . . . . . . . . . . . . .   7
       4.2.1.  s_init_cert_verify  . . . . . . . . . . . . . . . . .   9
       4.2.2.  s_new_ticket  . . . . . . . . . . . . . . . . . . . .  10
       4.2.3.  s_init_early_secret . . . . . . . . . . . . . . . . .  10
       4.2.4.  s_hand_and_app_secret . . . . . . . . . . . . . . . .  10
       4.2.5.  c_init_cert_verify  . . . . . . . . . . . . . . . . .  11
       4.2.6.  c_post_hand_auth  . . . . . . . . . . . . . . . . . .  11
     4.3.  session_id  . . . . . . . . . . . . . . . . . . . . . . .  11
     4.4.  freshness . . . . . . . . . . . . . . . . . . . . . . . .  12
     4.5.  ephemeral . . . . . . . . . . . . . . . . . . . . . . . .  13
       4.5.1.  e_generated:  . . . . . . . . . . . . . . . . . . . .  14
       4.5.2.  cs_generated: . . . . . . . . . . . . . . . . . . . .  14
       4.5.3.  no_secret . . . . . . . . . . . . . . . . . . . . . .  15
     4.6.  selected_identity . . . . . . . . . . . . . . . . . . . .  16
     4.7.  cert  . . . . . . . . . . . . . . . . . . . . . . . . . .  17
     4.8.  tag . . . . . . . . . . . . . . . . . . . . . . . . . . .  19
     4.9.  secret  . . . . . . . . . . . . . . . . . . . . . . . . .  20
     4.10. signature . . . . . . . . . . . . . . . . . . . . . . . .  21
   5.  LURK exchange on the TLS server . . . . . . . . . . . . . . .  22
     5.1.  s_init_cert_verify  . . . . . . . . . . . . . . . . . . .  22
     5.2.  s_new_tickets . . . . . . . . . . . . . . . . . . . . . .  25
     5.3.  s_init_early_secret . . . . . . . . . . . . . . . . . . .  26
     5.4.  s_hand_and_app_secret . . . . . . . . . . . . . . . . . .  27
   6.  LURK exchange on the TLS client . . . . . . . . . . . . . . .  29
     6.1.  c_init_post_hand_auth . . . . . . . . . . . . . . . . . .  31
     6.2.  c_init_cert_verify  . . . . . . . . . . . . . . . . . . .  33
     6.3.  c_post_hand_auth  . . . . . . . . . . . . . . . . . . . .  34
     6.4.  c_init_client_hello . . . . . . . . . . . . . . . . . . .  36
     6.5.  c_client_hello  . . . . . . . . . . . . . . . . . . . . .  38
     6.6.  c_hand_and_app_secret . . . . . . . . . . . . . . . . . .  39
     6.7.  c_register_tickets  . . . . . . . . . . . . . . . . . . .  41
   7.  Security Considerations . . . . . . . . . . . . . . . . . . .  41
   8.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  42
   9.  Acknowledgments . . . . . . . . . . . . . . . . . . . . . . .  43
   10. References  . . . . . . . . . . . . . . . . . . . . . . . . .  43
     10.1.  Normative References . . . . . . . . . . . . . . . . . .  43



Migault                  Expires 18 August 2022                 [Page 2]

Internet-Draft                LURK/TLS 1.3                 February 2022


     10.2.  Informative References . . . . . . . . . . . . . . . . .  43
   Appendix A.  Annex  . . . . . . . . . . . . . . . . . . . . . . .  44
     A.1.  TLS server ECDHE (no session resumption)  . . . . . . . .  44
       A.1.1.  ecdhe generated on CS . . . . . . . . . . . . . . . .  45
       A.1.2.  ecdhe generated by the TLS server . . . . . . . . . .  46
     A.2.  TLS server ECDHE ( with session resumption )  . . . . . .  47
     A.3.  TLS server PSK / PSK-ECDHE  . . . . . . . . . . . . . . .  48
     A.4.  TLS client unauthenticated ECDHE  . . . . . . . . . . . .  51
     A.5.  TLS client unauthenticated PSK / PSK-ECDHE  . . . . . . .  54
     A.6.  TLS client authenticated ECDHE  . . . . . . . . . . . . .  56
       A.6.1.  (EC)DHE or Proposed PSK protected by the CS . . . . .  56
       A.6.2.  (EC)DHE provided by the TLS client  . . . . . . . . .  57
     A.7.  TLS client authenticated - post handshake
           authentication  . . . . . . . . . . . . . . . . . . . . .  58
       A.7.1.  Initial Post Handshake Authentication . . . . . . . .  59
       A.7.2.  Post Handshake Authentication . . . . . . . . . . . .  59
   Author's Address  . . . . . . . . . . . . . . . . . . . . . . . .  60

1.  Introduction

   This document defines the LURK extension for TLS 1.3 The document
   considers the Private Key (PK) used generate signature of
   CertificateVerify message is always protected by the CS.
   Additionally PSK or the (EC)DHE secret key MAY also be protected by
   the CS.[RFC8446] also designated as 'tls13'.  This extension enables
   TLS 1.3 to be securely split between TLS 1.3 into a TLS Engine (E)
   and a Cryptographic Service (CS) for both the TLS client and the TLS
   server.

   This document assumes the reader is familiar with TLS 1.3 the LURK
   architecture [I-D.mglt-lurk-lurk].

   E interacts with a CS to perform three types of operations: perform a
   signature with a secret private key, generate secrets from the TLS
   1.3 key schedule or generate tickets for future sessions.  To limit
   the number of exchanges between E and CS, packs these operations
   across various possible LURK exchanges as summed up in
   Table Figure 1.  As a result, these exchanges do share many common
   structures, each exchange happens in a very specific state with a
   specific subset of structures that results in such exchange being
   uniquely defined.










Migault                  Expires 18 August 2022                 [Page 3]

Internet-Draft                LURK/TLS 1.3                 February 2022


   +--------+-----------------------+------------------------+
   |  Role  | LURK exchange         | secret | sign | ticket |
   +--------+-----------------------+--------+------+--------+
   | server | s_init_early_secret   | yes    |  -   |  -     |
   | server | s_init_cert_verify    | yes    | yes  |  -     |
   | server | s_hand_and_app_secret | yes    |  -   |  -     |
   | server | s_new_ticket          | yes    |  -   |  yes   |
   | client | c_init_post_hand_auth |  -     | yes  |  -     |
   | client | c_post_hand_auth      |  -     | yes  |  -     |
   | client | c_init_cert_verify    | yes    | yes  |  -     |
   | client | c_init_early_secret   | yes    |  -   |  -     |
   | client | c_init_hand_secret    | yes    |  -   |  -     |
   | client | c_hand_and_app_secret | yes    |  -   |  -     |
   | client | c_register_tickets    | yes    |  -   |  yes   |
   +--------+-----------------------+--------+------+--------+

              Figure 1: Operation associated to LURK exchange

2.  Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

   This document uses the terms defined [RFC8446] and
   [I-D.mglt-lurk-tls12].  However, we replaced [RFC8446] (EC)DHE
   authentication by certificate based authentication to make a clear
   distinction between the generation of the signature, and the
   generation of (EC)DHE which may only be involved in PSK based
   authentication.

   Private Key (PK)  designates the private key associated to the
      certificate.  PK is used to generate the signature of the
      CertificateVerify message when the TLS client or TLS server use
      certificate base authentication.

3.  LURK Header

   The LURK Extension described in this document is designated by a
   designation set to 'tls13' and a version set to 1.  The LURK
   Extension extends the LURKHeader structure defined in
   [I-D.mglt-lurk-lurk] as follows:







Migault                  Expires 18 August 2022                 [Page 4]

Internet-Draft                LURK/TLS 1.3                 February 2022


   enum {
       tls13 (2), (255)
   } Designation;

   enum {
      capabilities(0),  // to be removed
      ping(1),
      s_init_cert_verify(2),
      s_new_ticket(3),
      s_init_early_secret(4),
      s_hand_and_app_secret(5),
      c_binder_key(6),
      c_init_early_secret(7),
      c_init_hand_secret(8),
      c_hand_secret(9),
      c_app_secret(10),
      c_cert_verify(11),
      c_register_tickets(12),
      c_post_hand_auth(13), (255)
   }TLS13Type;


   enum {
       // generic values reserved or aligned with the
       // LURK Protocol
       request (0), success (1),
       invalid_extention // to be added in lurk lurk
       undefined_error (2),
       invalid_format (3),
       invalid_type  // to be added in lurk_lurk
       invalid_status // to be added in lurk_lurk

       invalid_secret_request // to be removed
       invalid_session_id
       invalid_handshake
       invalid_freshness
       invalid_ephemeral
       invalid_psk
       invalid_certificate
       invalid_cert_type

       ///not in the code
       invalid_key_id_type
       invalid_signature_scheme
       invalid_certificate_type
       invalid_certificate_verify
       invalid_identity
       too_many_identities



Migault                  Expires 18 August 2022                 [Page 5]

Internet-Draft                LURK/TLS 1.3                 February 2022


   }TLS13Status

   struct {
        Designation designation = "tls13";
        int8 version = 1;
   } Extension;

   struct {
       Extension extension;
       select( Extension ){
           case ("tls13", 1):
               TLS13Type;
       } type;
       select( Extension ){
           case ("tls13", 1):
               TLS13Status;
       } status;
       uint64 id;
       unint32 length;
   } LURKHeader;

4.  Structures

   This section describes structures that are widely re-used across the
   multiple LURK exchanges.

4.1.  secret_request

   secret_request is a 16 bit structure described in Table Figure 2 that
   indicates the requested key or secrets.  The same structure is used
   across multiple exchanges, but each exchange only permit a subset of
   values described in Table Figure 3.  For a given exchange, values or
   secrets that are not permitted MUST NOT be requested by E and MUST be
   ignored by the CS.  The secret request sent by E expresses a
   willingness for a given set of secrets.  CS SHOULD provide the
   requested secrets, its response may implement specific policies and
   CS MAY omit some requested permitted secrets as well as add some
   permitted secrets.













Migault                  Expires 18 August 2022                 [Page 6]

Internet-Draft                LURK/TLS 1.3                 February 2022


   +------+-------------------------------------------+
   | Bit  |      key or secret     (designation)      |
   +------+-------------------------------------------+
   | 0    | binder_key (b)                            |
   | 1    | client_early_traffic_secret (e_c)         |
   | 2    | early_exporter_master_secret (e_x)        |
   | 3    | client_handshake_traffic_secret (h_c)     |
   | 4    | server_handshake_traffic_secret (h_s)     |
   | 5    | client_application_traffic_secret_0 (a_c) |
   | 6    | server_application_traffic_secret_0 (a_s) |
   | 7    | exporter_master_secret (x)                |
   | 8    | resumption_master_secret (r)              |
   | 9-15 | reserved and set to zero                  |
   +------+-------------------------------------------+

                     Figure 2: secret_request structure

   +-----------------------+------------------------------+
   | LURK exchange         | Permitted secrets            |
   +-----------------------+------------------------------+
   | s_init_cert_verify    | h_c*, h_s*, a_c*, a_s*, x*   |
   | s_new_ticket          | r*                           |
   | s_init_early_secret   | b,e_c*, e_x*                 |
   | s_hand_and_app_secret | h_c, h_s, a_c*, a_s*, x*     |
   | c_init_post_hand_auth | -                            |
   | c_post_hand_auth      | -                            |
   | c_init_cert_verify    | a_c*, a_s*, x*               |
   | c_init_client_hello   | b*, e_c*, e_x*               |
   | c_client_hello        | b*, e_c*, e_x*               |
   | c_hand_and_app_secret | h_c, h_s, a_c*, a_s*, x*, r* |
   | c_register_tickets    | -                            |
   +-----------------------+------------------------------+
   * indicates the secret MAY be requested
   - indicates no secrets are requested

        Figure 3: secret_request permitted values per LURK exchange

4.2.  handshake

   The derivation of the secrets, signing operation and tickets requires
   the TLS handshake context as described in [RFC8446] section 4.  The
   necessary TLS handshake context is collected by CS in many ways.
   Firstly, E provides portions of the handshake during the multiple
   exchanges that is aggregated by the CS.  Table Figure 4 shows the
   expected portion of the handshake transmitted by E to CS for the
   various possible exchanges.  Secondly, CS generates some portions or
   update portions of the transmitted handshake provided by E.




Migault                  Expires 18 August 2022                 [Page 7]

Internet-Draft                LURK/TLS 1.3                 February 2022


   Note that Certificate are not carried via the handshake structure but
   the cert structure as detailled in Section 4.7.

   The handshake structure is defined as follows:

   "Handshake handshake<0..2^32> //RFC8446 section 4 (clear)"

   Table Figure 4 defines the content of the handshake parameter in the
   various exchanges.

   +-----------------------+------------------------------------------+
   | LURK exchange         | handshake content                        |
   +-----------------------+------------------------------------------+
   | s_init_cert_verify    | ClientHello ... later of                 |
   |                       | server EncryptedExtensions /             |
   |                       | CertificateRequest                       |
   | s_new_ticket          | earlier of client CertificateVerify /    |
   |                       | Finished ... Finished                    |
   | s_init_early_secret   | ClientHello                              |
   | s_hand_and_app_secret | ServerHello ... later of                 |
   |                       | server EncryptedExtensions /             |
   |                       | CertificateRequest                       |
   | c_init_post_hand_auth | ClientHello ... ServerHello              |
   |                       | CertificateRequest                       |
   | c_post_hand_auth      | CertificateRequest                       |
   | c_init_cert_verify    | ClientHello... later of server Finished/ |
   |                       | EndOfEarlyData                           |
   | c_init_client_hello   | (Partial) ClientHello  or                |
   |                       | ClientHello, HelloRetryRequest,          |
   |                       | (Partial) ClientHello                    |
   | c_client_hello        | HelloRetryRequest, (Partial) ClientHello |
   | c_hand_and_app_secret | ServerHello, {EncryptedExtensions}       |
   |                       | ... later of { server Finished } /       |
   |                       | EndOfEarlyData                           |
   | c_register_tickets    | -                                        |
   +-----------------------+------------------------------------------+

                Figure 4: handshake values per LURK exchange

   Upon receiving a handshake parameter, CS performs some checks
   described below:

   psk_proposed  A TLS handshake is "psk_proposed" when the TLS client
      proposes a PSK authentication.  The latest ClientHello contains a
      psk_key_exchange_modes (section 4.2.9 of [RFC8446]) and a
      pre_shared_key (section 4.2.11 of [RFC8446]) extension.

   psk_agreed  A "psk_proposed" TLS handshake is "psk_agreed" when the



Migault                  Expires 18 August 2022                 [Page 8]

Internet-Draft                LURK/TLS 1.3                 February 2022


      TLS server agrees and selects PSK to authenticate to be
      authenticated by the TLS client.  The ServerHello contains a
      pre_shared_key extension as according to [RFC8448] section 4.2.9
      the Server MUST NOT send a psk_key_exchange_modes extension.

   certificate_agreed  As currently defined, TLS 1.3 [RFC8446] provides
      only PSK or certificate authentication.  In addition, when the TLS
      server is authenticated with a certificate, according to [RFC8446]
      section 4.2.3), the ClientHello MUST contain a
      signature_algorithms extension.

   ks_proposed  A TLS handshake is "key shared proposed" when the
      computation of a (EC)DHE shared secret is proposed by the TLS
      client.  The latest ClientHello contains a key_share extension
      (section 4.2.8 of [RFC8446]).

   ks_agreed  A TLS handshake is key shared agreed or "ks agreed" when
      the TLS server agrees and complete the generation of a (EC)DHE
      shared secret.  The ServerHello contains a key_shared extension.

   certificate_request  A TLS handshake is "certificate request" when
      the TLS server has requested the client to authenticate via a
      certificate by sending a CertificateRequest message with a
      signature algorithm extension.

   early_data_proposed  A TLS handshake is "early_data_proposed" when it
      has indicates the presence of early data.  Its latest ClientHello
      contains a early_data extension (section 4.2.10 of [RFC8446].

   early_data_agreed  A TLS handshake is "early_data_agree" when a
      early_data extension is present in the Encrypted Extension.

   post_hand_auth_proposed:  A TLS handshake is
      "post_hand_auth_proposed" when the TLS client indicates the
      support of Post-Handshake Client Authentication.  The ClientHello
      contains a post_handshake_auth extension.

4.2.1.  s_init_cert_verify

   This exchange implies the authenticated mode is (EC)DHE and CS MUST
   check the handshake is not 'psk_agreed' and is both 'ks_proposed' and
   'ks_agreed'.  CS SHOULD raise an invalid_handshake error otherwise.

   CS applies the freshness function to the ServerHello.random as
   detailed in Section 4.4.  When instructed to, CS generates the
   (EC)DHE and add it to its local ServerHello as detailed in
   Section 4.5.




Migault                  Expires 18 August 2022                 [Page 9]

Internet-Draft                LURK/TLS 1.3                 February 2022


   The TLS server Certificate message is provided via the certificate
   structure detailed CS generates the Certificate message from the
   certificate structure.  CS SHOULD raise an invalid_handshake_error if
   the server Certificate message is in found in the handshake
   structure.Section 4.7 and not directly in the handshake structure.
   In fact, the server Certificate message is rather considered as a
   configuration whose transmission for each handshake is loading
   unnecessarily the CS.

   In addition to the server Certificate message, the CertificateVerify
   as described in Section 4.10 as well as the server Finished message
   as detailed in [RFC8446] section 4.4.4 to avoid a potential
   additional interaction between E and CS.

4.2.2.  s_new_ticket

   When the TLS handshake is "certificate request" the TLS handshake is
   expected to have a Certificate message provided by the certificate
   structure detailed Section 4.7 and not directly in the handshake
   structure.

4.2.3.  s_init_early_secret

   This exchange is expected to occur when a PSK has been selected and
   CS MUST check the handshake is 'psk_proposed' and SHOULD raise an
   invalid_handshake error otherwise.

   CS applies the freshness function to ServerHello.random as detailed
   in Section 4.4.

   CS MUST check the presence of an early_data extension in the
   ClientHello before generating the client_early_traffic_secret (e_x).
   If the extension is not found CS SHOULD NOT compute the secret.  Note
   that the secret may be generated by CS without knowing E actually
   agreed on using it.

4.2.4.  s_hand_and_app_secret

   This exchange is expected to occur when a PSK has been selected and
   CS MUST check the handshake is 'psk_agreed' and SHOULD raise an
   invalid_handshake error otherwise.  CS MUST check the ticket selected
   in the ServerHello is the same ticket as the one selected in the
   's_init_early_secret'.  To do so, CS MUST check
   SInitEarlySecret.selected_identity equals selected identity of the
   ServerHello pre_shared_key extension and SHOULD raise an
   invalid_handshake error otherwise.  Similarly, CS MUST check the
   selected selected cipher suite has the same KDF hash algorithm as
   that used to establish the original connection - as per {!RFC8446}



Migault                  Expires 18 August 2022                [Page 10]

Internet-Draft                LURK/TLS 1.3                 February 2022


   Section 4.6.1.  To do so, CS MUST check the cipher suite selected by
   the KDF hash algorithm associated to the ServerHello message
   corresponds to the one provided by the ticket and SHOULD raise an
   invalid_handshake error otherwise.

   When instructed to, CS generates the (EC)DHE and add it to its local
   ServerHello as detailed in Section 4.5.  CS also generates the server
   finished message as detailed in [RFC8446] section 4.4.4.

4.2.5.  c_init_cert_verify

   This exchange occurs when the TLS client is authenticated via its
   certificate.  CS MUST check the handshake indicates the TLS server
   has been authenticated via its certificate as well as that it
   contains a request from the TLS server for the client authentication.
   This is performed by checking the handshake is certificate_agreed,
   certificate_request.  In addition, CS MUST check the presence of a
   server CertificateVerify message.  Note also the Certificate message
   must be included but is not directly carried by the handshake
   structure, so the verification, if implemented by CS, can only be
   performed after the generation of the Certificate message as detailed
   in Section 4.7.

4.2.6.  c_post_hand_auth

   This exchange occurs when the TLS client is authenticated via its
   certificate after the main handshake.

   The CS MUST check E has indicated support of the post handshake
   client authentication.  This is enforced by checking the TLS
   handshake is post_hand_auth_proposed. c_post_hand_auth handshake is
   composed of the CertificateRequest message.

4.3.  session_id

   The session_id is a 32 bit identifier that identifies a LURK session
   between E and the CS.  Unless the exchange is sessionless, the
   session_id is negotiated at the initiation of the session where E
   (resp. the CS) indicates the value to be used for inbound session_id
   in the following exchanges.  For other exchanges, the session_id is
   set by the sender to the inbound value provided by the receiving
   party.  When CS receives an unexpected session_id CS SHOULD return an
   invalid_session_id error.

   The session_id structure is defined below: ~~~ uint32 session_id ~~~

   Table Figure 5 indicates the presence of the session_id for each
   exchange.



Migault                  Expires 18 August 2022                [Page 11]

Internet-Draft                LURK/TLS 1.3                 February 2022


+-----------------------+------------+
| LURK exchange         | session_id |
+-----------------------+------------+
| s_init_cert_verify    |      *     |
| s_new_ticket          |      y     |
| s_init_early_secret   |      y     |
| s_hand_and_app_secret |      y     |
| c_init_post_hand_auth |      *     |
| c_post_hand_auth      |      y     |
| c_init_cert_verify    |      *     |
| c_init_client_hello   |      y     |
| c_client_hello        |      y     |
| c_hand_and_app_secret |      y     |
| c_register_tickets    |      y     |
+-----------------------+------------+

y indicates the session_id is present
* indicates session_id may be present (depending on the tag.last_exchange)

                Figure 5: session_id in LURK exchanges

4.4.  freshness

   The freshness function implements perfect forward secrecy (PFS) and
   prevents replay attack.  On the TLS server, CS generates the
   ServerHello.random of the TLS handshake that is used latter to derive
   the secrets.  The ServerHello.random value is generated by CS using
   the freshness function and the ServerHello.random provided by E in
   the handshake structure.  CS operates similarly on the TLS client and
   generates the ClientHello.random of the TLS handshake using the
   freshness function as well as the ClientHello.random value provided
   by E in the handshake structure.

   If CS does not support the freshness, CS SHOULD return an
   invalid_freshness error.

   The freshness structure is defined as follows:

   enum { sha256(0), sha384(1), sha512(2), ... (255) } Freshness;

   Table {table:freshness} details the exchanges that contains the
   freshness structure.









Migault                  Expires 18 August 2022                [Page 12]

Internet-Draft                LURK/TLS 1.3                 February 2022


   +-----------------------+-----------+
   | LURK exchange         | freshness |
   +-----------------------+-----------+
   | s_init_cert_verify    |     y     |
   | s_new_ticket          |     -     |
   | s_init_early_secret   |     -     |
   | s_hand_and_app_secret |     y     |
   | c_init_post_hand_auth |     y     |
   | c_post_hand_auth      |     -     |
   | c_init_cert_verify    |     y     |
   | c_init_client_hello   |     y     |
   | c_client_hello        |     -     |
   | c_hand_and_app_secret |     -     |
   | c_register_tickets    |     -     |
   +-----------------------+-----------+

   y indicates freshness is present
   - indicates freshness is absent

                    Figure 6: freshness in LURK exchange

   When CS is running on the TLS server, the ServerHello.random is
   generated as follows:

   server_random = ServerHello.random
   ServerHello.random = freshness( server_random + "tls13 pfs srv" );

   When CS is running on the TLS client, the ClientHello.random is
   generated as follows:

   client_random = ClientHello.random
   ClientHello.random = freshness( client_random + "tls13 pfs clt" );

   The server_random (resp client_random) MUST be deleted once it has
   been received by the CS.  In some cases, especially when the TLS
   client enables post handshake authentication and interacts with CS
   via a (c_init_post_hand_auth) exchange, there might be some delay
   between the ClientHello is sent to the server and the Handshake
   context is shared with the CS.  The client_random MUST be kept until
   the post-handshake authentication is performed as the full handshake
   is provided during this exchange.

4.5.  ephemeral

   The Ephemeral structure carries the necessary information to generate
   the (EC)DHE shared secret used to derive the secrets.  This document
   defines the following ephemeral methods to generate the (EC)DHE
   shared secret:



Migault                  Expires 18 August 2022                [Page 13]

Internet-Draft                LURK/TLS 1.3                 February 2022


   *  e_generated: Where (EC)DHE keys and shared secret are generated by
      E and the shared secret is provided to the CS

   *  cs_generated: Where the (EC)DH keys and shared secret are
      generated by CS and the public key is returned to the E.

   *  no_secret: where no (EC)DHE is involved, and PSK authentication is
      performed.

4.5.1.  e_generated:

   When the (EC)DHE keys and (EC)DHE shared secret are generated by the
   E, E provides the shared secret value to the CS.  The shared secret
   is transmitted via the SharedSecret structure, which is similar to
   the key_exchange parameter of the KeyShareEntry described in CS MUST
   NOT return any data.  Note that CS is unable to check the (EC)DHE
   shared secret has been generated with the public keys provided either
   by the ClientHello or the ServerHello.[RFC8446] section 4.2.8.

   struct {
      NamedGroup group;
      opaque shared_secret[coordinate_length];
   } SharedSecret;

   Where coordinate_length depends on the chosen group.  For secp256r1,
   secp384r1, secp521r1, x25519, x448, the coordinate_length is
   respectively 32 bytes, 48 bytes, 66 bytes, 32 bytes and 56 bytes.
   Upon receiving the shared_secret, CS MUST check group is proposed in
   the KeyShareClientHello and agreed in the KeyShareServerHello.

4.5.2.  cs_generated:

   When the ECDHE public/private keys are generated by the CS, E
   requests CS the associated public value.  Note that in such cases CS
   would receive an incomplete Handshake Context from E with the public
   part of the ECDHE missing.  Typically the ServerHello message would
   present a KeyShareServerHello that consists of a KeyShareEntry with
   an empty key_exchange field, but the field group is present.

   CS MUST check the group field in the KeyShareServerHello, and get the
   public value of the TLS client from the KeyShareClientHello.  CS
   performs the same checks as described in [RFC8446] section 4.2.8.  CS
   generates the private and public (EC)DH keys, computes the shared key
   and return the KeyShareEntry server_share structure defined in
   [RFC8446] section section 4.2.8 to the LURK client.






Migault                  Expires 18 August 2022                [Page 14]

Internet-Draft                LURK/TLS 1.3                 February 2022


   Note: The use of an empty KeyShareEntry results in the length of the
   ServerHello, the ServerHello.extensions and the KeyShareServerHello
   sent by E to CS to be increases to the size of the coordinate length
   of the chosen group before being added to the Handshake context of CS
   or being sent to the TLS client by the E.

4.5.3.  no_secret

   With PSK authentication, (EC)DHE keys and shared secrets are not
   needed.  CS MUST check the PSK authentication without (EC)DHE has
   been agreed.  More specifically, CS MUST check the handshake is
   'psk_proposed', 'psk_agreed' and is not 'ks_agreed' as detailed in
   [RFC8446] section 4.2.9.

   When the ephemeral method or the group is not supported, expected
   extensions are not found CS SHOULD return an invalid_ephemeral error.

   Table {table:ephemeral} indicates the exchanges that contain the
   ephemeral parameter as well as the permitted methods.

+-----------------------+-----------+---------------------------+
|                       |           |  ephemeral_method= secret |
| LURK exchange         | ephemeral | no | provided | generated |
+-----------------------+-----------+----+----------+-----------+
| s_init_cert_verify    |     y     | -  |    y     |     y     |
| s_new_ticket          |     -     | -  |    -     |     -     |
| s_init_early_secret   |     -     | -  |    -     |     -     |
| s_hand_and_app_secret |     y     | y  |    y     |     y     |
| c_init_post_hand      |     y     | -  |         |          |
| c_post_hand_auth           |     y     | -  |         |          |
| c_init_cert_verify    |     y     | -  |    y     |    -      |
| c_init_client_hello   |     y     | y  |         |          |
| c_client_hello        |     y     | y  |         |          |
| c_hand_and_app_secret |     y     | y  |         |          |
| c_register_tickets    |     -     | -  |         |          |
+-----------------------+-----------+----+----------+-----------+

y indicates presence of ephemeral or possible value for ephemeral_method
- indicates absent or ephemeral or incompatible value for ephemeral_method

              Figure 7: Ephemeral field in LURK exchange

   The EphemeralRequest and EphemeralResponse structures are defined as
   follows:







Migault                  Expires 18 August 2022                [Page 15]

Internet-Draft                LURK/TLS 1.3                 February 2022


enum { no_secret (0), e_generated(1), cs_generated(2) (255)} EphemeralMethod;

EphemeralRequest {
    EphemeralMethod method;
    select(method) {
        case e_generated:
            SharedSecret shared_secret<0..2^16>;
    }
}

EphemeralResponse {
    select(method) {
        case cs_generated:
            KeyShareEntry server_share
  }
}

4.6.  selected_identity

   The selected_identity indicates the identity of the PSK used in the
   key schedule.  The selected_identity expresses index of the
   identities in the in the ClientHello pre_shared_key extension as
   expressed in [RFC8446] section 4.2.11.

   The selected_identity structure is defined as follows:

   uint16 selected_identity; //RFC8446 section 4.2.11

   +-----------------------+-----+
   | LURK exchange         | req |
   +-----------------------+-----+
   | s_init_cert_verify    |  -  |
   | s_new_ticket          |  -  |
   | s_init_early_secret   |  y  |
   | s_hand_and_app_secret |  -  |
   | c_init_post_hand_auth |  -  |
   | c_post_hand_auth      |  -  |
   | c_init_cert_verify    |  -  |
   | c_init_client_hello   |  -  |
   | c_client_hello        |  -  |
   | c_hand_and_app_secret |  -  |
   | c_register_tickets    |  -  |
   +-----------------------+-----+

   y indicates the selected_identity is present
   - indicates the selected_identity is absent

                     Figure 8: psk_id in LURK exchange



Migault                  Expires 18 August 2022                [Page 16]

Internet-Draft                LURK/TLS 1.3                 February 2022


   CS retrieve the PSK identity from the ClientHello and SHOULD send an
   invalid_psk error if an error occurs.  For the TLS server, CS MUST
   check the selected_identity parameter matches the selected_identity
   of the ServerHello as described in Section 4.2.

4.7.  cert

   cert indicates the presence or absence of a Certificate message as
   well as the necessary input for the generation of such message.  cert
   supports different type of compressed certificates defined by a
   cert_type.

   cert is essentially motivated to enable compression of the
   Certificate message similarly to CompressedCertificate [RFC8879].
   The reason to to use a specific cert parameter is that
   CompressedCertificate is negotiated between the TLS client and the
   TLS server - with some implications on teh ClientHello extensions -
   while here the communication is between E and the CS.  All related
   certificate information are handled by this parameter and Certificate
   message MUST not be provided via the handshake parameter.

   cert supports FingerPrintCertificate to compress the Certificate
   message when certificates are configured on both E and the CS.  This
   expected to be used for client Certificate exchanged on the TLS
   client between CS and E or server Certificate exchanged on the TLS
   server between E and the CS.  The compressed format is a
   FingerPrintCertificate which contains a list of
   FingerPrintCertificateEntry where each opaque certificate data -
   RawPublicKey or X509 content as described in [RFC8446] section 4.4.2
   - is instead replaced by the 4 byte finger_print of these certificate
   data.  The finger_print consists in the 4 first bytes of the output
   hash of the certificate using SHA256 as the hashing function.

   cert also supports the CompressedCertificate [RFC8879] or the
   uncompressed Certificate message format.

   Finally, cert also indicates the absence of Certificate message with
   a special no_certificate type.

   CS MUST support the no_certificate, the finger_print an uncompressed
   cert_type.  CS SHOULD raise a 'invalid_cert_type' error when it
   receives a unsupported cert_type and 'invalid_cert' when any other
   error occurs.

   When (EC)DHE authentication has been agreed (the handshake is not in
   psk_agreed), CS MUST check the presence of a server Certificate
   message and reject and raise a 'invalid_certificate' error if
   cert_type is set to no_certificate.  When the handshake is



Migault                  Expires 18 August 2022                [Page 17]

Internet-Draft                LURK/TLS 1.3                 February 2022


   psk_proposed and psk_agreed, CS MUST check the absence of server
   Certificate and raise an 'invalid_certificate' if cert_type is not
   set to no_certificate.  When the handshake is certificate_request, CS
   MUST check the presence of a client Certificate message and raise an
   'invalid_certificate' if cert_type is not set to no_certificate.

   The cert structure is defined as follows:

enum { zlib(1),  brotli(2),  zstd(3), no_certificate(128), finger_print(129), uncompressed(130), (255)
} CertType;

struct{
    select (certificate_type) {
              case RawPublicKey:
                uint32 finger_print;
              case X509:
                uint32 finger_print;
          };
          Extension extensions<0..2^16-1>;
} FingerPrintCertificateEntry;

struct {
    opaque certificate_request_context<0..2^8-1>;
    FingerPrintCertificateEntry certificate_list<0..2^24-1>;
} FingerPrintCertificate;



struct {
    CertType cert_type;
    select (cert_type) {
        case zlib, brotlib, zstd:
          CompressedCertificate certificate; RFC8879 section 4
        case no_certificate:
          // no certificate
        case finger_print
            uint24 uncompressed_length;
            FingerPrintCertificate certificate;
        case uncompressed:
            Certificate certificate; // RFC8446 section 4.4.2
    };
} Cert;

   certificate  structure carrying the compressed form of the
      Certificate message.  The current format supported are
      CompressedCertificate as detailed in [RFC8879],
      FingerPrintCertificate, and Certificate certificate as detailed in
      [RFC8446] section 4.4.2.



Migault                  Expires 18 August 2022                [Page 18]

Internet-Draft                LURK/TLS 1.3                 February 2022


   certificate_list  A sequence (chain) of FingerPrintCertificateEntry
      structures, each containing a single certificate and set of
      extensions.

   certificate_request_context, extensions, certificate_type are defined
   in [RFC8446] section 4.4.2.

   finger_print  the first 4 bytes of the resulting SHA256 output of the
      certificate in DER format or the ASN.1_subjectPublicKeyInfo
      [RFC7250].

   Table Figure 9 indicates the presence of that field in the LURK
   exchanges.

   +-----------------------+-------------+-------------------+
   | LURK exchange         | certificate | certificate type  |
   +-----------------------+-------------+-------------------+
   | s_init_cert_verify    |      y      | server            |
   | s_new_ticket          |      *      | client            |
   | s_init_early_secret   |      -      |                   |
   | s_hand_and_app_secret |      -      |                   |
   | c_init_post_hand_auth |      y      | client            |
   | c_post_hand_auth      |      y      | client            |
   | c_init_cert_verify    |      y      | client and server |
   | c_init_client_hello   |      -      |                   |
   | c_client_hello        |      -      |                   |
   | c_hand_and_app_secret |      y      | client            |
   | c_register_tickets    |      -      |                   |
   +-----------------------+-------------+-------------------+

   * indicates certificate type MAY be set to no_certificate.
   y indicates certificate type MUST NOT be set to 'no_certificate'
   - indicates the certificate structure is absent

                      Figure 9: cert in LURK exchange

4.8.  tag

   This field provides extra information.  Currently, the tag structure
   defines tag.last_exchange and tag.cert_request.

   E or CS sets the tag.last_exchange to terminate the LURK session.
   When E is expecting the current exchange to be the last one, it sets
   the tag.last_exchange to True.  CS MUST respond with a
   tag.last_exchange set to True and E MUST ignore any other values.
   When E does not expect the current message to be the last one it sets
   the tag.last_exchange to False.  CS responds with a tag.last_exchange
   set to False to confirm additional exchanges may be performed.  On



Migault                  Expires 18 August 2022                [Page 19]

Internet-Draft                LURK/TLS 1.3                 February 2022


   the other hand, CS may also indicates this is the last exchange and
   set tag.last_exchange to True, in which case E MUST reset the session
   and MUST NOT proceed to any further exchanges.

   In this document, we use setting, setting to True to indicate the bit
   is set to 1.  Respectively, we say unsetting, setting to False to
   indicate the bit is set to 0.

   Table Figure 10 indicates the different values carried by the tag as
   well as the exchange these tags are considered.  The bits values MUST
   be ignored outside their exchange context and bits Bits that are not
   specified within a given exchange MUST be set to zero by the sender
   and MUST be ignored by the receiver.

   +------+----------------+
   | Bit  | description    |
   +------+----------------+
   | 0    | last_exchange  |
   | 1-7  | RESERVED       |
   +------+----------------+

                         Figure 10: tag description

   +-----------------------+--------------+--------------+
   | LURK exchange         | last_exchange | cert_request |
   +-----------------------+--------------+--------------+
   | s_init_cert_verify    |       y      |       -      |
   | s_new_ticket          |       y      |       -      |
   | s_init_early_secret   |       -      |       -      |
   | s_hand_and_app_secret |       y      |       -      |
   | c_init_post_hand_auth |       y      |       -      |
   | c_post_hand_auth      |       y      |       -      |
   | c_init_cert_verify    |       y      |       -      |
   | c_init_client_hello   |       -      |       -      |
   | c_client_hello        |       -      |       _      |
   | c_hand_and_app_secret |       y      | y (response) |
   | c_register_tickets    |       y      |       -      |
   +-----------------------+--------------+--------------+

   y indicates tag is present
   - indicates tag is absent

                      Figure 11: tag per LURK exchange

4.9.  secret

   The Secret structure is used by CS to send the various secrets
   derived by the key schedule described in [RFC8446] section 7.



Migault                  Expires 18 August 2022                [Page 20]

Internet-Draft                LURK/TLS 1.3                 February 2022


   The Secret structure is defined as follows:

   enum {
       binder_key (0),
       client_early_traffic_secret(1),
       early_exporter_master_secret(2),
       client_handshake_traffic_secret(3),
       server_handshake_traffic_secret(4),
       client_application_traffic_secret_0(5),
       server_application_traffic_secret_0(6),
       exporter_master_secret(7),
       esumption_master_secret(8),
       (255)
   } SecretType;

   struct {
       SecretType secret_type;
       opaque secret_data<0..2^8-1>;
   } Secret;

   secret_type: The type of the secret or key

   secret_data: The value of the secret.

4.10.  signature

   The signature requires the signature scheme, a private key and the
   appropriated context.  The signature scheme is provided using the
   SignatureScheme structure defined in [RFC8446] section 4.2.3, the
   private key is derived from the certificate Section 4.7 and the
   context is derived from the handshake Section 4.2 and certificate
   Section 4.7.

   Signing operations are described in [RFC8446] section 4.4.3.  The
   context string is derived from the role and the type of the LURK
   exchange as described below.  The Handshake Context is taken from the
   key schedule context.

   +--------------------+-------------------------------------+
   | type               | context                             |
   +--------------------+-------------------------------------+
   | s_init_cert_verify | "TLS 1.3, server CertificateVerify" |
   | c_cert_verify      | "TLS 1.3, client CertificateVerify" |
   +--------------------+-------------------------------------+

   The signature structure is defined as follows:





Migault                  Expires 18 August 2022                [Page 21]

Internet-Draft                LURK/TLS 1.3                 February 2022


   struct {
       opaque signature<0..2^16-1>; //RFC8446 section 4.4.3.
   } Signature;

5.  LURK exchange on the TLS server

   This section describes exchanges performed on the TLS server.  Unless
   specified, used structures are described in Section 4

   The interaction between E and CS are relatively straight forward as
   the TLS server is able select how it will be authenticated, that is
   either using the certificate or the PSK with (EC)DHE or the PSK only.
   If the TLS server selects to be authenticated via its certificate, E
   request CS, via a s_init_cert_verify, to generate the signature, as
   well as handshake, application and exporter secrets to complete the
   handshake.  If the TLS server selects to be authenticated via a PSK E
   request CS, via a s_init_early_secret, at least the binder key to
   validate the binders as well as other early secrets to complete the
   handshake.  Once the ticket has been validated, E requests CS the
   handshake and application secrets and optionally the generation of
   the (EC)DHE.

   Once, the handshake has been completed, E may request the generation
   of tickets to enable session resumption.  This is again a server side
   decision which may be performed via a s_new_ticket exchange.

   The remaining of the section describes CS behavior.  Implementation
   may differ from the description and generates the response otherwise.
   The response SHOULD however remain coherent with the description
   provided.

5.1.  s_init_cert_verify

   s_init_cert_verify initiates a LURK session when the server is
   authenticated with (EC)DHE.  E sends a SInitCertVerifyRequest to CS
   and is responded a SInitCertVerifyResponse structure unless an error
   is being raised.














Migault                  Expires 18 August 2022                [Page 22]

Internet-Draft                LURK/TLS 1.3                 February 2022


   struct{
       uint8 tag;
       select (tag.last_exchange){
         case False:
           uint32 session_id;
       }
       FreshnessFunct freshness;
       Ephemeral ephemeral;
       Handshake handshake<0..2^32>; //RFC8446 section 4
       Cert certificate;
       uint16 secret_request;
       SignatureScheme sig_algo; //RFC8446 section 4.2.3.
   }SInitCertVerifyRequest

   struct{
       uint8 tag;
       select (tag.last_exchange){
         case False:
           uint32 session_id;
       }
       Ephemeral ephemeral;
       Secret secret_list<0..2^16-1>;
       Signature signature;
   }SInitCertVerifyResponse

   sig_algo  SignatureScheme is defined in [RFC8446] section 4.2.3.

   For other parameters, see the corresponding sections tag
   (Section 4.8), session_id (Section 4.3), freshness (Section 4.4),
   ephemeral (Section 4.5), handshake (Section 4.2), certificate
   (Section 4.7), secret_request (Section 4.1), signature
   (Section 4.10), secret_list (Section 4.9).

   If the exchange is expected to be followed by a s_new_ticket
   exchange, typically to enable session resumption, E set the
   tag.last_exchange to False as described in Section 4.8.

   When tag.last_exchange is set to False, E indicates in the session_id
   structure, the session identifier used to further identify the
   inbound session - see Section 4.3 for more details.  If
   tag.last_exchange is set to True, the session_id structure is ignored
   by the E.

   E sets the freshness function as detailed in Section 4.4.  It is
   RECOMMENDED to use a freshness function that provides similar
   security as TLS Hash function.





Migault                  Expires 18 August 2022                [Page 23]

Internet-Draft                LURK/TLS 1.3                 February 2022


   E either generates the (EC)DHE or requests CS to generates, in which
   case it respectively sets the ephemeral.ephemeral_method to
   'e_generated' or 'cs_generated' and proceeds as described in
   Section 4.5.

   E provides the necessary TLS Handshake context in handshake and
   certificate as respectively detailed in Section 4.2 and Section 4.7.

   The necessary secrets E needs to complete the exchange as well as the
   signature scheme used to generate the signature are indicated by
   secret_request and sig_algo as described in Section 4.1 and
   Section 4.10.

   Upon receiving the SInitCertVerifyRequest, CS generates the
   ServerHello.random as detailed in Section 4.4 to implement anti
   replay protection.

   Then, CS generates the (EC)DHE to further initialize the key schedule
   as described in [RFC8466] section 7.1.  As described Section 4.5, the
   (EC)DHE is either directly provided by E ('e_generated') or computed
   by CS ('cs_generated').  When (EC)DHE are generated by the CS,
   necessary information are provided by the partial key_share
   extension.  CS completes the key share extension and returns that
   necessary information to E in the ephemeral response.

   Once (EC)DHE is computed, CS generates the handshake secrets (h_c,
   h_s ) as described in [RFC8446] section 7.1, compute the Certificate
   message from the certificate and complete the TLS handshake in order
   to have the necessary TLS Handshake context to generate the
   signature.

   CS then generates the signature, provides the resulting value in the
   signature field of the response and complete the CeriticateVerify
   message that inserted into the TLS handshake context of the CS, so
   the Finished message can be generated.  This provides the necessary
   TLS Handshake context for the generation of the application secrets
   (a_c, a_s)

   Once generated, the requested secrets are returned in secret_list as
   detailed in Section 4.1 and Section 4.9.











Migault                  Expires 18 August 2022                [Page 24]

Internet-Draft                LURK/TLS 1.3                 February 2022


5.2.  s_new_tickets

   new_session ticket handles session resumption.  It enables to
   retrieve NewSessionTickets that will be forwarded to the TLS client
   by the TLS server to be used later when session resumption is used.
   It also provides the ability to delegate the session resumption
   authentication from CS to E as the possession of the
   resumption_master_secret (r) is sufficient to proceed to session
   resumption.  It is important to realize that performing session
   resumption outside CS may have some security implications -
   especially when CS provides a more secure environment than the E.  CS
   MAY responds with a resumption_master_secret based on its policies.

   The LURK client MAY perform multiple s_new_ticket exchanges.

   The SNewTicketRequest and SNewTicketResponse are described below:

   struct {
       uint8 tag
       uint32 session_id
       Handshake handshake<0..2^32> //RFC8446 section 4.
       Cert certificate;
       uint8 ticket_nbr;
       uint16 secret_request;
   } SNewTicketRequest;


   struct {
       uint8 tag
       uint32 session_id
       Secret secret_list<0..2^16-1>;
       NewSessionTicket ticket_list<0..2^16-1>; //RFC8446 section 4.6.1.
   } SNewTicketResponse;

   ticket_nbr: designates the requested number of NewSessionTicket.  In
   the case of delegation this number MAY be set to zero.  CS MAY
   responds with less tickets when the value is too high.

   For other parameters, see the corresponding sections tag
   (Section 4.8), session_id (Section 4.3), handshake (Section 4.2),
   certificate (Section 4.7), secret_request (Section 4.1), secret_list
   (Section 4.9).

   When E is requesting CS to generate tickets, as described in
   Section 4.3 E sets the session_id with the value received in the
   SInitCertVerifyResponse or the SInitEarlySecretResponse of the
   previous exchange.




Migault                  Expires 18 August 2022                [Page 25]

Internet-Draft                LURK/TLS 1.3                 February 2022


   E MUST ensure CS has sufficient TLS Handshake context, that is the
   client Finished and optionally the client Certificate and
   CertificateVerify messages have been provided.  When these messages
   have been already provided, E SHOULD NOT provide them again and CS
   MAY upon configuration raise an invalid_handshake error.  In such
   case, E may resend its request with the appropriated empty handshake
   and certificate.

   Note that client Certificate are carried via certificate, which
   enables to compress the Certificate payload.

   E may set the secret_request to 'r'.

   Upon receiving a SNewTicketRequest CS check the tag.last_exchange and
   define if further messages are expected or not by setting the
   tag.last_exchange in its response.  The session_id is set to the
   value provided in the SInitCertVerifyRequest or the
   SInitEarlySecretRequest of the previous exchange.

   If CS does not have sufficient handshake context and
   invalid_handshake error is raised as described in Section 4.2.  If
   the ticket_nbr exceeds the maximum number of ticket authorized by the
   CS, an authorized lower number of tickets is returned and if not
   further tickets can be requested, the tag.last_exchange MUST be set
   to True to close the session.  If a lower number of ticket is
   returned while tag.last_exchange is set to False, E interpret it as a
   maximum number of ticket per transaction, and may initiate further
   s_new_tickets exchanges.

5.3.  s_init_early_secret

   s_init_early_secret initiates a LURK session when the server is
   authenticated by the PSK or PSK-ECDHE methods.

   The SInitEarlySecretRequest and SInitEarlySecretResponse are define
   dbelo9w:















Migault                  Expires 18 August 2022                [Page 26]

Internet-Draft                LURK/TLS 1.3                 February 2022


   struct{
       uint32 session_id
       FreshnessFunct freshness
       uint16 selected_identity
       Handshake handshake<0..2^32> //RFC8446 section 4
       uint16 secret_request;
   }SInitEarlySecretRequest

   struct{
       uint32 session_id
       Secret secret_list<0..2^16-1>;
   }SInitEarlySecretResponse

   selected_identity  indicates the selected PSK as detailed in
      Section 4.6.

   For other parameters, see the corresponding sections session_id
   (Section 4.3), freshness (Section 4.4), handshake (Section 4.2),
   secret_request (Section 4.1), secret_list (Section 4.9).

   When E agrees to perform a PSK base server authentication, it sends a
   SInitEarlySecretRequest to the CS.  The session_id are generated as
   described in the s_init_cert_verify exchange (see Section 5.1.  The
   binder_key MUST be requested, since it is used to validate the PSK.
   If the TLS client has indicated support for early application data
   via the early_data extension and if the TLS server enable early_data,
   E requests the client_early_traffic_secret (e_c).  E MAY also request
   the early_exporter_master_secret (e_x).

   CS MUST check the handshake corresponds to a PSK authentication, that
   is the handshake is, for the partial ClientHello, the handshake is
   psk_proposed - see Section 4.2 for more details.  CS selects the PSK
   indicated by the selected_identity and initiates the key scheduler
   before generating the requested secrets.  The key schedule is
   instantiated with the PSK and TLS hash function provided by the
   ticket.  As detailed in Section 4.1, CS MUST generate the binder_key
   and check the binders.  If e_c has been requested, CS MUST check the
   presence of an early_data extension in the ClientHello before
   generating e_c (see Section 4.2 ).  The generation of both e_c and
   e_x is subject CS policies.

5.4.  s_hand_and_app_secret

   The s_hand_and_app_secret follows the s_init_early_secret exchange
   and enable the generation of h_c, h_s, a_c, a_s and x.  When the
   (EC)DHE private key is generated by the CS, this exchange also
   provides the corresponding public key necessary to complete the
   ServerHello.



Migault                  Expires 18 August 2022                [Page 27]

Internet-Draft                LURK/TLS 1.3                 February 2022


   The SHandAndAppSecretRequest and SHandAndAppSecretResponse structures
   are described below:

   struct{
       uint8 tag
       uint32 session_id
       Ephemeral ephemeral
       Handshake handshake<0..2^32> //RFC8446 section 4
       uint16 secret_request;
   } SHandAndAppSecretRequest

   struct{
       uint8 tag
       uint32 session_id
       Ephemeral ephemeral
       Secret secret_list<0..2^16-1>;
   } SHandAndAppSecretResponse

   Parameters are defined in their corresponding sections tag
   (Section 4.8), session_id (Section 4.3), ephemeral (Section 4.5),
   handshake (Section 4.2), secret_request (Section 4.1), secret_list
   (Section 4.9).

   To send a SHandAndAppSecretRequest, E sets the tag.last_exchange as
   described in Section 5.1.  As described in Section 4.3 E sets the
   session_id with the value received in the SInitEarlySecretResponse.
   If E does decides the TLS server is authenticated with the PSK mode
   without (EC)DHE, it sets ephemeral.ephemeral_method to 'no_secret'.
   If the TLS server is authenticated with PSK and (EC)DHE, then the
   ephemeral.ephemeral_method can be set to 'e_generated' or
   'cs_generated' depending whether E or CS generates the (EC)DHE
   private key.



















Migault                  Expires 18 August 2022                [Page 28]

Internet-Draft                LURK/TLS 1.3                 February 2022


   Upon receiving the SHandAndAppSecretRequest sets the
   tag.last_exchange as described in Section 5.1.  The session_id is set
   to the value provided in the SInitEarlySecretRequest. ephemeral is
   generated as described in Section 5.1 when ephemeral method is set to
   'e_generated' or 'cs_generated' and a method set to 'no_secret' does
   not trigger any action.  CS MUST check the handshake is coherent both
   to PSK or PSK with (EC)DHE as well as the ServerHello is coherent
   with the choices indicated in the previous SHandAndAppSecretRequest.
   More specifically, the handshake must be psk_agreed for an PSK
   authentication without (EC)DHE.  When PSK authentication with (EC)DHE
   has been selected, the handshake MUST be psk_agreed ks_proposed and
   ks_agreed.  Then CS MUST also ensure the selected_identity indicated
   in the ServerHello corresponds to the one provided in the
   SInitEarlySecretRequest and that the cipher_suite of the ServerHello
   has the same hash function as the one provided by the ticket - see
   Section 4.2.

   CS generates the ServerHello.random as detailed in Section 4.4 to
   implement anti replay protection.  Withe the ServerHello message set,
   the handshake secrets are generated with the key schedule initiated
   during the s_init_early_secret.  CS then generates the Finished
   message before generating the application and exporter secrets.

6.  LURK exchange on the TLS client

   Figure Figure 12 summarizes the different possible LURK session as
   well as the different messages that are involved in the session.

   Similarly to the TLS server, the credentials involved in the TLS
   client authentication are PK, (EC)DHE and PSK.  This document assumes
   PK, when involved, is always protected by the CS.  Unlike the TLS
   server, the TLS client can be authenticated within the TLS handshake
   as well as in a post handshake client authentication exchange.

   During the TLS handshake, the TLS client can be authenticated using a
   certificate base authentication or a PSK based authentication.  Note
   that according to [RFC8446] section 4.3.2, certificate based
   authentication for the TLS client is only allowed when the TLS
   server's authentication is also certificate based.

   Protection by CS of the client certificate authentication works
   similarly to the certificate based authentication on the TLS server
   side.  CS can protect the PK only or both the PK and the (EC)DHE
   private key.  When (EC)DHE is protected by the CS, E requests the CS,
   via a c_init_client_hello exchange, the (EC)DHE public key to build
   and send its ClientHello.  Upon receiving the ServerHello, E
   requests, via a c_all exchange, handshake, application and exporter
   secrets, and the signature of the client CertificateVerify.  E is



Migault                  Expires 18 August 2022                [Page 29]

Internet-Draft                LURK/TLS 1.3                 February 2022


   able to build the client Finished message and send it to the TLS
   server to complete the TLS handshake.  When (EC)DHE is not protected
   by the CS, E can build the ClientHello message without any
   interaction with CS and only requests, via a c_init_cert_verify
   exchange, CS to generates the signature of the client
   CertificateVerify message and complete the handshake.

   Protection by CS of the PSK based authentication is provided with CS
   protecting the PSK and optionally the (EC)DHE or only the (EC)DHE to
   later bootstrap to protected authentication for session resumption.
   In any case, E requests the PSK binder_key or (EC)DHE public key to
   the CS, via a c_init_client_hello, to build and send the ClientHello.
   Upon receiving the ServerHello, handshake, application and exporter
   secrets are generated via a c_all exchange, to complete the
   handshake.

   Once the handshake is completed, the TLS server may request a client
   post handshake authentication.  If the TLS client has not been
   authenticated or at least without involving the CS, E perform the
   post handshake authentication via a c_init_post_hand_auth.  On the
   contrary, the authentication is performed via a c_post_hand_auth.

   In addition, once the handshake has been completed, E may register
   the ticket received from the TLS server to CS via a
   c_register_tickets exchange.

   The remaining of the section describes CS behavior.  Implementation
   may differ from the description and generates the response otherwise.
   The response SHOULD however remain coherent with the description
   provided.





















Migault                  Expires 18 August 2022                [Page 30]

Internet-Draft                LURK/TLS 1.3                 February 2022


   ClientHello    ^   (EC)DHE generated by CS    no
     Derivation   |   or PSK in CS Proposed -------+
   ClientHello    |       yes |                    |
     sent      -->v    c_init_client_hello         |
   ServerHello -->^           |         ks_proposed/agreed no
     received     |           |         certificate_agree --+
                  |           |                yes |        |
   ServerHello    |         c_all         c_init_cert_verify|
     Treatment    |           |                    |        |
   clientFinished |           +-------+------------+        |     no
     sent      -->v                   |        post_auth_proposed --+
                  ^                   |                     +       |
                  |                   |         CertificateRequest  |
                  |                   |                     |       |
                  |                   |        c_init_post_hand_auth|
                  |                   |                     |       |
                  |+----------------->|<--------------------+       |
   Posthandshake  ||        +---------+-------+                     |
   Treatment      ||        |                 |                     |
                  ||post_auth_proposed  (EC)DHE generated by CS or  |
                  ||        +           PSK in use in CS            |
                  ||CertificateRequest        +                     |
                  ||        |          NewSessionTicket             |
                  ||        |                 |                     |
                  ||c_post_hand_auth c_register_tickets             |
                  ||        |                 |                     |
                  ||        +-------+---------+                     |
                  ||                |                               |
                  v+----------------+                         +-----+
                                    |                         |
                               LURK session         LURK session
                               closed               not initiated

                    Figure 12: LURK client State Diagram

6.1.  c_init_post_hand_auth

   The c_init_post_hand_auth occurs when the TLS client performs post
   handshake authentication while no previous interactions occurred
   between the TLS client and the CS.

   The TLS server MAY authenticated via its certificate but as this is
   the initial interaction between E and CS, if PSK authentication is
   used, the PSK is not protected by CS.  Similarly, (EC)DHE is neither
   protected by CS and as we assumed the client PK is protected by CS,
   the client has not been authenticated with its certificate.





Migault                  Expires 18 August 2022                [Page 31]

Internet-Draft                LURK/TLS 1.3                 February 2022


   struct{
     uint8 tag;
     select (tag.last_exchange){
       case False:
         uint32 session_id;
     }
     FreshnessFunct freshness;
     Handshake handshake<0..2^32> //RFC8446 section 4
     Cert server_certificate;
     Cert client_certificate
   }CInitPostHandAuthRequest


   struct{
     unit8 tag
     select (tag.last_exchange){
       case False:
         uint32 session_id;
     }
     Signature signature
   }CInitPostHandAuth

   After the TLS handshake is completed

   tag  is defined in Section 4.8.  The TLS client sets
      tag.last_exchange if further post handshake authentications are
      expected.  Similarly CS sets the tag.last_exchange if further post
      handshake authentications are permitted.  Note that it is out of
      scope of this specification to specify the reasons, but it is
      RECOMMENEDED CS sets life time to LURK session as well as limits
      the maximum number of post handshake authentications.

   ephemeral  is defined in Section 4.5 and ephemeral_method MUST be set
      to 'e_generated' when the TLS handshake agreed an ECDHE or a PSK-
      ECDHE authentication.  The ephemeral_method MUST be set to
      'no_secret' when PSK the TLS handshake agreed on PSK
      authentication.

   handshake  is defined in Section 4.2 and post handshake
      authentication MUST be enabled by the TLS client.

   cert  is defined in Section 4.7 and is used by the TLS client to
      indicate the expected certificate to be used to compute the
      signature as well as the certificate that is expected to be send
      further to the TLS server.

   sig_algo  is defined in Section 4.10 and indicates the selected
      algorithm.



Migault                  Expires 18 August 2022                [Page 32]

Internet-Draft                LURK/TLS 1.3                 February 2022


   signature  is defined in Section 4.10.

6.2.  c_init_cert_verify

   The c_init_cert_verify exchange occurs when the TLS client is being
   requested to authenticate during the TLS handshake.  This exchange is
   used when only PK is protected by CS and E has generated the (EC)DHE
   shared secret, as well as any necessary secrets, and the only output
   expected from CS is the signature.

   The CInitCertVerifyRequest and CInitCertVerifyResponse are detailed
   below:

   struct{
       uint8 tag;
       select (tag.last_exchange){
         case False:
           uint32 session_id;
       }
       FreshnessFunct freshness;
       Ephemeral ephemeral; ## e_generated
       Handshake handshake<0..2^32>; //RFC8446 section 4
       Cert server_certificate;
       Cert client_certificate
       SignatureScheme sig_algo; //RFC8446 section 4.2.3.
   }CInitCertVerifyRequest

   struct{
       uint8 tag;
       select (tag.last_exchange){
         case False:
           uint32 session_id;
       }
       Signature signature;
   }CInitCertVerifyResponse

   As detailed in [RFC8446] section 4.4, the generation requires some
   Handshake context as well as the client_handshake_traffic_secret
   (h_c) which is generated by the key schedule and requires the (EC)DHE
   shared secret.  CS does not have any previous knowledge of the TLS
   handshake and all information need to be provided to CS.










Migault                  Expires 18 August 2022                [Page 33]

Internet-Draft                LURK/TLS 1.3                 February 2022


   E MUST set tag.last_exchange to True unless post handshake
   authentication has been enabled by E with a post_handshake_auth"
   extension of the ClientHello.  In such case, E needs to determine if
   further post handshake handshake may be requested by the TLS server,
   and set it stag.last_exchange accordingly.  Typically, an application
   that is only looking for a single client authentication within the
   TLS handshake or as a post handshake may set tag.last_exchange to
   True upon authenticating the client in the TLS handshake.

   E splits the necessary Handshake context which includes the server
   Certificate as well as the client Certificate between the
   server_certificate, teh client_certificate and the handshake
   structure.  E protects the exchange from being replayed by setting
   the ClientHello.random as described Section 4.4 and set freshness
   accordingly.  The (EC)DHE share secret is provided via the ephemeral
   and ephemeral.ephemeral_method is set to 'e_generated'.

   Upon receiving a CInitCertVerifyRequest, CS checks the
   tag.last_exchange to determine the presence of a session_id.  As
   detailed in ((sec:tag}}, CS sets tag.last_exchange of the
   CInitCertVerifyResponse to False if E has set it False, the handshake
   is post_hand_auth_proposed and the CS policy permits it.  Otherwise
   tag..last_exchange is set to True.

   According to [RFC8446] client authentication during the TLS handshake
   is not valid with a PSK or PSK based authentication.  The Handshake
   context MUST check the handshake is certificate_agree and
   certificate_request with the presence of server Certificate,
   CertificateRequest, server CertificateVerify messages.  As the
   Certificate message is generated from the certificate structure, its
   presence may be checked after it has been generated by the CS or
   independently in the certificate and handshake structures.

   CS then updates the ClientHello.random with the freshness function as
   described in Section 4.4.

   CS checks the ephemeral.ephemeral_method is set to 'e_generated' and
   initiates the key schedule to compute the h_c with the shared secret.
   Once h_c has been computed, insert the client Certificate and
   computes the signature.  If TLS client expects additional post
   handshake authentication, CS computes the CertificateVerify and
   Finished messages.

6.3.  c_post_hand_auth

   If the TLS client has indicated support for post handshake client
   authentication, the TLS client MAY receive a CertificateRequest from
   the TLS server.



Migault                  Expires 18 August 2022                [Page 34]

Internet-Draft                LURK/TLS 1.3                 February 2022


   To proceed to the requested authentication, E proceeds to a
   c_post_hand_auth exchange with the CS.

   The CPostHandAuthRequest and CPostHandAuthResponse are detailed
   below:

   struct{
     Tag tag
     uint32 session_id
     Handshake handshake<0..2^32> // CertificateRequest
     Cert client_certificate;
     SignatureScheme sig_algo;
   }CPostHandAuthRequest


   struct{
     Tag tag
     uint32 session_id
     Signature signature
   }CPostHandAuthResponse

   E indicates with tag if it is expecting CS to proceed to additional
   post handshake client authentication - see Section 4.8. session_id is
   set to the negotiated session_id provided by the CS for its inbound
   traffic - see Section 4.3. handshake contains the CertificateRequest
   received by the TLS server, and sig_algo the signature scheme
   selected by E and N which indicates the
   client_application_traffic_secret_N used to be used.

   Upon receiving a CPostHandAuthRequest, CS checks the handshake is
   post_hand_auth_proposed as described in Section 4.2 and SHOULD return
   an 'invalid_handshake' error otherwise.  If the CS permits a limited
   number of post handshake client authentication, and that limit has
   been reached, it SHOULD raise an 'invalid_type' error.  Note that in
   some cases, such as with a c_cert_verify exchange, CS SHOULD resets
   the session, if post handshake is not supported which result in the
   session not being found.  CS MUST check client_certificate.cert_type
   is not set to 'no_certificate', the provided certificate is known to
   CS.  The certificate is eventually decompressed and added to the
   handshake context as described in Section 4.7.  Note also that for
   the client, the Certificate includes the certificate_request_context
   provided by the CertificateRequest message as described in [RFC8446]
   section . The signature is computed as detailed in [RFC8446] section
   4.4.  CS MAY have a limit of permitted number of post handshake, and
   set tag.last_exchange to True when that limit is reached.






Migault                  Expires 18 August 2022                [Page 35]

Internet-Draft                LURK/TLS 1.3                 February 2022


6.4.  c_init_client_hello

   The c_init_ephemeral_binder exchange occurs when the TLS client needs
   to generate the ClientHello as well as the early secrets.  In fact
   the generation of the ClientHello may require CS to generates the
   (EC)DHE private key and returns the public part as well as the
   binder_key to generate the binders.  On the other hand, the
   generation of the early secrets requires the ClientHello to be
   completed.  As a result, CS will be expected to complete the
   ClientHello from a potential partial ClientHello.  More specifically,
   when binders are needed, the partial Client Hello does not contains
   the OfferedPsks structure, that is the PreSharedKeyExtension.  The
   latter structure is simply stripped from the ClientHello, without any
   further changes, such as changing the lengths for example.  It is
   entirely built by CS and append as the last extension as described in
   section 4.2.11 of The reason for having CPskID as opposed to the
   identity structure is that nothing prevent identities of two
   different NewSessionTickets to be collide.  CPskID are managed by CS
   of the TLS client to prevent such collisions and are provided during
   the registration of the NewSessionTickets c_register_tickets (see
   [RFC8446].  Note that extension_type as well as the 16 bit length of
   the OfferedPsks remain present.  The PreSharedKeyExtension structure
   of the ClientHello is built from a list of CPskIDs where each CPskID
   designates a PSK with an identifier managed by CS of the TLS client.
   The PSK can be associated to a NewSessionTicket in which case the
   CPskID will be used to designate the NewSessionTicket and its
   associate identity structure.Section 6.7).  When the PSK is
   provisioned, the TLS client needs to be configured with it.  When CS
   is not able to generate the PreSharedKeyExtension an invalid_identity
   error SHOULD be raised.

   Note that when PSK is not proposed or when PSK are not registered in
   the CS, the ClientHello is fully provided - without the
   PreSharedKeyExtension or with a completed PreSharedKeyExtension
   extension.  CS is expected to be able to distinguish between the two
   by for example, comparing the length of the handshake provided in
   c_init_client_hello and the length indicated in the ClientHello.














Migault                  Expires 18 August 2022                [Page 36]

Internet-Draft                LURK/TLS 1.3                 February 2022


   Note that (EC)DHE may be generated when ECDHE or PSK-ECDHE
   authentication is proposed by the TLS client, while early secrets and
   binder_key can only be requested when PSK is proposed.  When the TLS
   client requests the generation of a (EC)DHE private key, the
   KeyShareClietHello MAY contain a list of KeyShareEntry (defined in
   section 4.2.8 When an error is found regarding the
   KeyShareClientHello, CS SHOULD raise an invalid_ephemeral error.
   Note that according to [RFC8446] ).  When provided, these structures
   contains the group but are being stripped the key_exchange_value,
   while all other fields - including the lengths - are left
   unchanged.Section 4.5 when the ephemeral_method is set to
   'no_secret', the resulting list is empty.

   This exchange is followed by a c_client_hello or a
   c_hand_and_app_secret.

   struct{
     uint32 c_psk_id
   }CPskID

   struct{
     uint32 session_id
     Freshness freshness
     Ephemeral ephemeral ephemeral_method=secret_generate or no_secret
     Handshake handshake<0..2^32> //RFC8446 section 4
     CPskID c_psk_id_list<0..2^8-1>
     uint16 secret_request;
   }CInitClientHello

   struct{
     uint32 session_id
     Ephemeral ephemeral_list<0..2^16-1>
     Secret secret_list<0..2^16-1>;
   }CInitClientHello

   session_id, freshness and ephemeral, secret_request and secret_list
   are respectively defined in Section 4.3, Section 4.4, Section 4.5,
   Section 4.1 and Section 4.9.

   ephemeral  is defined in Section 4.5.  With a single ClientHello or
      partial ClientHello, ephemeral_method is set to secret_generate
      when ECDHE and PSK-ECDHE authentication are being proposed or
      no_secret when only PSK is proposed or when the ECDHE is generated
      by the TLS client.

      Note that even though the CLientHello requests multiple
      KeyShareENtries, a single ephemeral method is provided.




Migault                  Expires 18 August 2022                [Page 37]

Internet-Draft                LURK/TLS 1.3                 February 2022


   handshake  is defined in Section 4.2.  When a partial ClientHello is
      provided, PSK or PSK-ECDHE MUST be enabled.  When a ClientHello is
      provided, PSK or PSK-ECDHE may be proposed but with unprotected
      keys.  ClientHello, HelloRetryRequest, ClientHello or ClientHello,
      HelloRetryRequest, partial ClientHello MAY be provided.  However,
      there are cases this is not possible, typically when the
      HellRequestRetry does not contain a key_share extension, the
      (EC)DHE shared secret is generated with the (EC)DHE generated
      associated to the first ClientHello.  When the (EC)DHE private key
      has been generated by the CS, the TLS client MUST use a
      c_early_secret LURK exchange as defined in Section 6.5 in order to
      ensure CS is aware of the (EC)DHE shared secret to generate the
      further secrets.

   c_psk_id  designate an 32 bit identifier for a PSK.  This identifier
      is provided and managed by CS of the TLS client to avoid collision
      of different PSK provided by different TLS servers.

   c_psk_id_list  designates the list of CPskIDs.  The list is used by
      CS to build the OfferedPsks structure - including the PSKIdentity
      structure.  The list of identities in the OfferedPsks MUST be the
      same as the one of the c_psk_id_list.

   ephemeral_list  When contains the different values of (EC)DHE public
      parts - i.e. the KeyShareEntries when the ephemeral_method is set
      to cs_generated.  When the ephemeral_method is set to no_secret,
      the list is an empty list by construction of the ephemeral
      structure (see Section 4.5).

6.5.  c_client_hello

   The c_client_hello exchange occurs after a TLS server responds to a
   ClientHello generated using a c_init_client_hello defined in
   Section 6.4 is being responded a HelloRetryRequest by the TLS server.
   While in some cases, re-initiating a LURK exchange with a
   _init_client_hello MAY be considered, this document RECOMMENDS to
   proceed as follows when a HelloRetryRequest is received:

   *  If the first ClientHello has been generated via a
      c_init_client_hello, use c_client_hello to generate the second
      ClientHello

   *  If the first ClientHello has not been generated via a
      c_init_client_hello, consider generating the second ClientHello
      via c_init_client_hello.

   This exchange is followed by a c_hand_and_app_secret.




Migault                  Expires 18 August 2022                [Page 38]

Internet-Draft                LURK/TLS 1.3                 February 2022


   struct{
     uint32 session_id
     Freshness freshness
     Ephemeral ephemeral ephemeral_method=secret_generate or no_secret
     Handshake handshake<0..2^32> //RFC8446 section 4
     uint16 secret_request;
   }CClientHello

   struct{
     uint32 session_id
     Ephemeral ephemeral
     Secret secret_list<0..2^16-1>;
   }CClientHello

   session_id, ephemeral, secret_request and secret_list are
   respectively defined in Section 4.3, Section 4.5, Section 4.1 and
   Section 4.9.

   handshake  is defined in Section 4.2.  The handshake MUST contain a
      HelloRetryRequest and a ClientHello or partial ClientHello.  The
      same restrictions as defined in Section 6.4 apply to the
      ClientHello

6.6.  c_hand_and_app_secret

   The c_hand_and_app_secret exchange occurs after a ServerHello is
   received and the TLS client request handshake secrets to decrypt
   (resp. encrypt) handshake messages sent by (resp. to) the server.
   Similarly the TLS client requests application secrets used to protect
   the TLS session as well as other secrets such as exporter secrets.

   Upon receiption of the handshake CS derives the handshake secrets and
   the server_handshake_traffic_secret as described in [RFC8446] section
   7.3 to decrypt the encrypted messages.  The presence of a
   CertificateRequest indicates the TLS server expects the TLS client to
   authenticate via a CertificateVerify message.  If CS protects a
   private key associated to the TLS client, CS MUST provides the
   necessary information to the TLS client client.  Otherwise, the
   CertificateRequest is ignored by the CS.

   When CS generates the signature, the presence of the certificate, the
   signature and sig_algo is indicated by setting tag.cert_request.
   Unlike on the TLS server, where the TLS server indicates the
   certificate to chose as well as the signature scheme to select, on
   the TLS client, such decision is left to the CS.  The choice of the
   signature algorithm and certificate is performed by CS as described
   in When resumption_master_secret is requested by the TLS client, or
   when further exchanges between teh TLS client and CS are expected, CS



Migault                  Expires 18 August 2022                [Page 39]

Internet-Draft                LURK/TLS 1.3                 February 2022


   generates the CertificateVerify and Finished message to synchronize
   the TLS handshake context.  The Certificate, respectively
   CertificateVerify and Finished message are generated as described in
   [RFC8446] section 4.4.2.3.  [RFC8446] section 4.4.2, section 4.4.3,
   and section 4.4.4.

   This exchange is followed by a c_post_hand_auth, c_register_ticket
   exchange.

   struct{
     uint8 tag;
     uint32 session_id;
     Ephemeral ephemeral;
     Handshake handshake<0..2^32>; //RFC8446 section 4
     uint16 secret_request;
   }CHandAndAppSecretRequest

   struct{
     uint8 tag;
     uint32 session_id;
     Secret secret_list<0..2^16-1>;
     select( tag.cert_request){
       case true:
         LURKTLS13Certificate certificate;
         SignatureScheme sig_algo;
         Signature signature;
     }
   }CHandAndAppSecretRequest

   session_id, secret_request certificate signature, and secret_list are
   respectively described in Section 4.3, Section 4.1, Section 4.7,
   Section 4.10 and Section 4.9

   tag  is defined in Section 4.8 and indicates whether the further
      exchanges are expected or not.  If the TLS client or the TLS
      server do not expect to perform session resumption or have not
      enabled post handshake authentication the tag.last_exchange SHOULD
      be set.

   ephemeral  is defined in Section 4.5.  Since ClientHello as already
      been sent, the purpose of the ephemeral is to provid ethe (EC)DHE
      shared secret to perform the key schedule and ephemeral_method
      MUST NOT be set to cs_generated.

   handshake  is defined in Section 4.2 and includes the ServerHello up
      to the server Finished.  These messages are passed to CS
      encrypted.




Migault                  Expires 18 August 2022                [Page 40]

Internet-Draft                LURK/TLS 1.3                 February 2022


   sig_algo  is defined in Section 4.10 and defines the algorithm chosen
      by the CS.

6.7.  c_register_tickets

   The c_register_ticket is only used when the TLS client intend to
   perform session resumption.  The LURK client MAY provide one or
   multiple NewSessionTickets.  These tickets will be helpful for the
   session resumption to bind the PSK value to some identities.  As teh
   NewSessionTicket's identities may collide when being provided by
   multiple TLS servers, CS provides identities it manages to prevent
   such collisions (CPskID).  One such CPskID is assigned to each ticket
   and is later used to designate that ticket (see Section 6.4).  When
   too many tickets are provided, CS SHOULD raise a too_many_identities
   error.

   struct {
     uint8 tag
     uint32 session_id
     NewSessionTicket ticket_list<0..2^16-1>; //RFC8446 section 4.6.1.
   } RegisterTicketsRequest;

   struct {
     uint8 tag
     uint32 session_id
     CPskID c_spk_id_list<0..2^8-1>
   } RegisterTicketsResponse;

7.  Security Considerations

   Security credentials as per say are the private key used to sign the
   CertificateVerify when ECDHE authentication is performed as well as
   the PSK when PSK or PSK-ECDHE authentication is used.

   The protection of these credentials means that someone gaining access
   to the CS MUST NOT be able to use that access from anything else than
   the authentication of an TLS being established.  In other way, it
   MUST NOT leverage this for: * any operations outside the scope of TLS
   session establishment. * any operations on past established TLS
   sessions * any operations on future TLS sessions * any operations on
   establishing TLS sessions by another LURK client.

   CS outputs are limited to secrets as well as NewSessionTickets.  The
   design of TLS 1.3 make these output of limited use outside the scope
   of TLS 1.3.  Signature are signing data specific to TLS 1.3 that
   makes the signature facility of limited interest outside the scope of
   TLS 1.3.  NewSessionTicket are only useful in a context of TLS 1.3
   authentication.



Migault                  Expires 18 August 2022                [Page 41]

Internet-Draft                LURK/TLS 1.3                 February 2022


   ECDHE and PSK-ECDHE provides perfect forward secrecy which prevents
   past session to be decrypted as long as the secret keys that
   generated teh ECDHE share secret are deleted after every TLS
   handshake.  PSK authentication does not provide perfect forward
   secrecy and authentication relies on the PSK remaining sercet.  The
   Cryptographic Service does not reveal the PSK and instead limits its
   disclosure to secrets that are generated from the PSK and hard to be
   reversed.

   Future session may be impacted if an attacker is able to authenticate
   a future session based on what it learns from a current session.
   ECDHE authentication relies on cryptographic signature and an ongoing
   TLS handshake.  The robustness of the signature depends on the
   signature scheme and the unpredictability of the TLS Handshake.  PSK
   authentication relies on not revealing the PSK.  CS does not reveal
   the PSK.  TLS 1.3 has been designed so secrets generated do not
   disclose the PSK as a result, secrets provided by the Cryptographic
   do not reveal the PSK.  NewSessionTicket reveals the identity
   (ticket) of a PSK.  NewSessionTickets.ticket are expected to be
   public data.  It value is bound to the knowledge of the PSK.  The
   Cryptographic does not output any material that could help generate a
   PSK - the PSK itself or the resumption_master_secret.  In addition,
   the Cryptographic only generates NewSessionTickets for the LURK
   client that initiates the key schedule with CS with a specific way to
   generate ctx_id.  This prevents the leak of NewSessionTickets to an
   attacker gaining access to a given CS.

   If an the attacker get the NewSessionTicket, as well as access to the
   CS of the TLS client it will be possible to proceed to the
   establishment of a TLS session based on the PSK.  In this case, the
   CS cannot make the distinction between the legitimate TLS client and
   teh attacker.  This corresponds to the case where the TLS client is
   corrupted.

   Note that when access to CS on the TLS server side, a similar attack
   may be performed.  However the limitation to a single re-use of the
   NewSessionTicket prevents the TLS server to proceed to the
   authentication.

   Attacks related to other TLS sessions are hard by design of TLS 1.3
   that ensure a close binding between the TLS Handshake and the
   generated secrets.  In addition communications between the LURK
   client and the CS cannot be derived from an observed TLS handshake
   (freshness function).  This makes attacks on other TLS sessions
   unlikely.

8.  IANA Considerations




Migault                  Expires 18 August 2022                [Page 42]

Internet-Draft                LURK/TLS 1.3                 February 2022


9.  Acknowledgments

10.  References

10.1.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC7250]  Wouters, P., Ed., Tschofenig, H., Ed., Gilmore, J.,
              Weiler, S., and T. Kivinen, "Using Raw Public Keys in
              Transport Layer Security (TLS) and Datagram Transport
              Layer Security (DTLS)", RFC 7250, DOI 10.17487/RFC7250,
              June 2014, <https://www.rfc-editor.org/info/rfc7250>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/info/rfc8174>.

   [RFC8446]  Rescorla, E., "The Transport Layer Security (TLS) Protocol
              Version 1.3", RFC 8446, DOI 10.17487/RFC8446, August 2018,
              <https://www.rfc-editor.org/info/rfc8446>.

   [RFC8448]  Thomson, M., "Example Handshake Traces for TLS 1.3",
              RFC 8448, DOI 10.17487/RFC8448, January 2019,
              <https://www.rfc-editor.org/info/rfc8448>.

   [RFC8466]  Wen, B., Fioccola, G., Ed., Xie, C., and L. Jalil, "A YANG
              Data Model for Layer 2 Virtual Private Network (L2VPN)
              Service Delivery", RFC 8466, DOI 10.17487/RFC8466, October
              2018, <https://www.rfc-editor.org/info/rfc8466>.

   [RFC8879]  Ghedini, A. and V. Vasiliev, "TLS Certificate
              Compression", RFC 8879, DOI 10.17487/RFC8879, December
              2020, <https://www.rfc-editor.org/info/rfc8879>.

10.2.  Informative References

   [I-D.mglt-lurk-lurk]
              Migault, D., "LURK Protocol version 1", Work in Progress,
              Internet-Draft, draft-mglt-lurk-lurk-01, 26 July 2021,
              <https://www.ietf.org/archive/id/draft-mglt-lurk-lurk-
              01.txt>.






Migault                  Expires 18 August 2022                [Page 43]

Internet-Draft                LURK/TLS 1.3                 February 2022


   [I-D.mglt-lurk-tls12]
              Migault, D. and I. Boureanu, "LURK Extension version 1 for
              (D)TLS 1.2 Authentication", Work in Progress, Internet-
              Draft, draft-mglt-lurk-tls12-05, 26 July 2021,
              <https://www.ietf.org/internet-drafts/draft-mglt-lurk-
              tls12-05.txt>.

Appendix A.  Annex

A.1.  TLS server ECDHE (no session resumption)

   This section illustrates the most common exchange of a TLS client
   authenticates a TLS server with it certificate (ECDHE) without
   session resumption.

   The TLS handshake is depicted below from {!RFC8446}}.  For clarity as
   ECDHE authentication is performed, PSK related extensions (
   psk_key_exchange_modes, pre_shared_key ) have been omitted.  In
   addition, as the TLS client is not authenticated, CertificateRequest
   sent by the TLS server as well as Certificate and CertificateVerify
   sent by the TLS client have been removed.

 TLS client                                   TLS Server

   Key  ^ ClientHello
   Exch | + key_share
        v + signature_algorithms --------->
                                            ServerHello  ^ Key
                                            + key_share  v Exch
                                  {EncryptedExtensions}    Server Params
                                          {Certificate}  ^
                                    {CertificateVerify}  | Auth
                                             {Finished}  v
                         <--------  [Application Data*]
     {Finished}              -------->
     [Application Data]      <------->  [Application Data]

   The TLS server interacts with CS with a s_init_cert_verify exchange
   in order to respond to the ClientHello.

   Since there is no session resumption, the request indicates with the
   tag set to last_exchange that no subsequent messages are expected.
   As a result, no session_id is provided.  The freshness function is
   set to sha256, the handshake is constituted with the appropriated
   messages with a modified server_random to provide PFS.  The
   Certificate message is also omitted from the handshake and is instead
   provided in the certificate structure using a finger_print.  The
   requested secrets are handshake and application secrets, that is h_s,



Migault                  Expires 18 August 2022                [Page 44]

Internet-Draft                LURK/TLS 1.3                 February 2022


   h_c, a_s, and a_c.  The signature scheme is ed25519.  With
   authentication based on certificates, there are two ways to generate
   the shared secrets that is used as an input to the derive the
   secrets.  The ECDHE private key and shared secret may be generated by
   CS as described in {sec:ex:srv:cs_generated}.  On the other hand the
   ECDHE private key and shared secret may be generated by the TLS
   server as described in {tls_server_generated}

A.1.1.  ecdhe generated on CS

   When the (EC)DHE private key and shared secrets are generated by the
   CS, the LURK client set the ephemeral_method to cs_generated.  The
   (EC)DHE group x25519 is specified in the handshake in the key_share
   extension.  In return CS provides the LURK client the public key so
   the TLS server can send the ServerHello to the TLS client.

   In this scenario, CS is the only entity that knows the private ECDHE
   key and the shared secret, and only CS is able to compute the
   secrets.  CS indicates the exchange is final by setting the tag to
   last_exchange, returns the x25519 public key that will be included in
   the ServerHello key_share extension, the signature sig that will be
   returned in the CertificateVerify message as well as the secrets that
   will be used to derive the appropriated keys.

   TLS server
   LURK client                              Cryptographic Service
     SInitCertVerifyRequest
       tag=last_exchange        -------->
       freshness = sha256
       ephemeral
         ephemeral_method = cs_generated
       handshake = handshake (x25519)
       certificate = finger_print
       secret_request = h_s, h_c, a_s, and a_c
       sig_algo = ed25519
                                      SInitCertVerifyResponse
                                        tag=last_exchange
                                        ephemeral
                                          key
                                            group = x25519,
                                            key_exchange = public_key
                                        secret_list
                                        signature = sig
                                <---------







Migault                  Expires 18 August 2022                [Page 45]

Internet-Draft                LURK/TLS 1.3                 February 2022


A.1.2.  ecdhe generated by the TLS server

   When the (EC)DHE private keys and the shared secrets are generated by
   the TLS server, the LURK client provides the shared secret to CS as
   only the shared secret is necessary to generated the signature.  This
   is indicated by the ephemeral_method set to e_generated.  No (EC)DHE
   values are returned by CS as these have already been generated by the
   TLS server.  However, the TLS server has all the necessary material
   to generate the secrets and the only information that CS owns and
   that is not known to et TLS server is the private key (associated to
   the certificate) used to generate the signature.  This means that is
   session resumption were allowed, since it is based on PSK
   authentication derived from the resumption secret, these sessions
   could be authenticated by the TLS server without any implication from
   the CS.

   In this scenario, CS is the only entity that knows the private ECDHE
   key.  Only CS is able to generate the signature.  Both CS and the TLS
   server are able to compute all secrets.  CS indicates the exchange is
   final by setting the tag to last_exchange, returns the signature sig
   that will be returned in the CertificateVerify message as well as -
   when requested - the secrets that will be used to derive the
   appropriated keys.

   TLS server
   LURK client                              Cryptographic Service
     SInitCertVerifyRequest
       tag.last_exchange=True   -------->
       freshness = sha256
       ephemeral
         ephemeral_method = e_generated
         key
           group = x25519
           shared_secret = shared_secret
       handshake = handshake
       certificate = finger_print
       secret_request = h_s, h_c, a_s, and a_c
       sig_algo = ed25519
                                      SInitCertVerifyResponse
                                        tag.last_exchange=True
                                        secret_list
                                        signature = sig
                                      <---------








Migault                  Expires 18 August 2022                [Page 46]

Internet-Draft                LURK/TLS 1.3                 February 2022


A.2.  TLS server ECDHE ( with session resumption )

   When the TLS client is enabling session resumption, the TLS server is
   expected to generate some tickets that will be later used for later
   sessions.  The generation of the tickets is based on the
   resumption_master_secret.  To ensure protection of the authentication
   credential used for the session resumption, CS necessarily must have
   generated the (EC)DHE keys and must not have provided the
   resumption_master_secret.  In either other cases, the TLS client is
   able to compute the resumption_master_secret and so session
   resumption is out of control of the CS.  As a result, CS sort of
   achieves a delegation to the TLS server.

   In the remaining of this section, we consider the session resumption
   is performed by the CS.

   ECDHE authentication is performed with CS generating the private part
   of the (EC)DHE as described in {sec:ex:srv:cs_generated}.  However,
   additional s_new_ticket exchanges are needed so the TLS server
   provides sufficient material to generate the tickets by CS and
   retrieves the generated tickets by the CS.  As result, the main
   difference with the scenario described in {sec:ex:srv:cs_generated}
   is that tag carries a session_id to identify the session between the
   TLS server and the CS.

   TLS server
   LURK client                              Cryptographic Service
     SInitCertVerifyRequest
       tag.last_exchange=False
       session_id = session_id_tls_server    -------->
       freshness = sha256
       ephemeral
         ephemeral_method = cs_generated
       handshake = handshake (x25519)
       certificate = finger_print
       secret_request = h_s, h_c, a_s, a_c
       sig_algo = ed25519
                                      SInitCertVerifyResponse
                                        tag.last_exchange=False
                                        session_id = session_id_cs
                                        ephemeral
                                          key
                                            group = x25519,
                                            key_exchange = public_key
                                        secret_list
                                        signature = sig
                                <---------




Migault                  Expires 18 August 2022                [Page 47]

Internet-Draft                LURK/TLS 1.3                 February 2022


   To enable session resumption, the TLS server needs to send
   NewSessionTickets to the TLS client.  This exchange is taken from
   [RFC8446] and represented below: ~~~ TLS client TLS Server <-----
   [NewSessionTicket] ~~~

   The TLS server requests NewSessionTicket to CS by sending a
   SNewTicketRequest.  The tag.last_exchange set to False indicates to
   CS the TLS server is willing to request NewSessionTickets multiple
   times.  The session_id is set to the value provided previously by the
   CS.  This session_id will be used to associate the SNewTicketRequest
   to the specific context of teh TLS handshake. handshake is the
   remaining handshake necessary to generate the secrets.  In some
   cases, when the TLS client is authenticated, the TLS handshake
   contains a Certificate message that is carried in the certificate
   structure as opposed as to the handshake structure.  In our current
   case, the TLS client is not authenticated, so the certificate_type is
   set to 'empty'.  ticket_nbr is an indication of the number of
   requested NewSessionTicket, and secret_list indicates the requested
   secrets.  In our case the resumption_master_secret (r) will remain in
   CS and will be anyway ignored by the CS, so the secret_request has
   its r bit unset.

   As depicted below, CS provides a list of tickets that could be later
   used in order to authenticate the TLS server using PSK or PSK-ECDHE
   authentication as describe din {sec:ex:srv:server-psk}.

 TLS server
 LURK client                              Cryptographic Service
   SNewTicketRequest
     tag.last_exchange=False
     session_id = session_id_cs
     handshake = client Finished
     certificate
       certificate_type = empty
     ticket_nbr
     secret_request  -------->
                                    SNewTicketResponse
                                      tag.last_exchange=False
                                      session_id = session_id_tls_server
                                      secret_list
                         <---------   ticket_list

A.3.  TLS server PSK / PSK-ECDHE

   PSK/PSK-ECDHE authentication is the method used for session
   resumption but can also be used outside the scope of session
   resumption.  In both cases, the PSK is hosted by the CS.




Migault                  Expires 18 August 2022                [Page 48]

Internet-Draft                LURK/TLS 1.3                 February 2022


   The PSK authentication can be illustrated by the exchange below:

   TLS client                                   TLS Server
     ClientHello
     + key_share
     + psk_key_exchange_mode
     + pre_shared_key          -------->
                                                     ServerHello
                                                + pre_shared_key
                                                    + key_share
                                           {EncryptedExtensions}
                                                      {Finished}
                               <--------     [Application Data*]

   The TLS client may propose to the TLS server multiple PSKs.

   Each of these PSKs is associated a PskBindersEntry defined in
   [RFC8446] section 4.2.11.2.  PskBindersEntry is computed similarly to
   the Finished message using the binder_key and the partial
   ClientHello.  The TLS server is expected to pick a single PSK and
   validate the binder.  In case the binder does not validate the TLS
   Handshake is aborted.  As a result, only one binder_key is expected
   to be requested by the TLS server as opposed to the TLS client.  In
   this example we assume the psk_key_exchange_mode indicated by the TLS
   client supports PSK-ECDHE as well as PSK authentication.  The
   presence of a pre_shared_key and a key_share extension in the
   ServerHello indicates that PSK-ECDHE has been selected.

   While the TLS handshake is performed in one round trip, the TLS
   server and CS have 2 LURK exchanges.  These exchanges are consecutive
   and performed in the scope of a LURK session.  A first exchange
   (s_init_early_secret) validates the ClientHello receives by the TLS
   server and existence of the selected PSK (by the TLS server) is
   actually hosted by the CS.  Once the s_init_early_secret exchange
   succeeds, the TLS server starts building the ServerHello and requests
   the necessary parameters derived by CS to complete the ServerHello
   with a second exchange (s_init_hand_and_apps).

   The TLS server is expected to select a PSK, check the associated
   binder and proceed further.  If the binder fails, it is not expected
   to proceed to another PSK, as a result, the TLS server is expected to
   initiates a single LURK session.

   The SInitEarlySecretRequest structure provides the session_id that
   will be used later by the TLS server to identify the session with
   future inbound responses from CS (session_id_server).  The freshness
   function (sha256) is used to implement PFS together with the
   ClientHello.random.  selected_identity indicates the PSK chosen by



Migault                  Expires 18 August 2022                [Page 49]

Internet-Draft                LURK/TLS 1.3                 February 2022


   the TLS server among those proposed by the TLS client in its
   ClientHello.  The secrets requested by the TLS server are indicated
   in secret_request.  This example shows only the binder_key, but other
   early secrets may be requests as well.

   CS responds with a SInitEarlySecretResponse that contains the
   session_id_cs used later to identify the incoming packets associated
   to the LURK session and the binder_key.

   TLS server
   LURK client                              Cryptographic Service
     SInitEarlySecretRequest ---------->
       session_id = session_id_tls_server
       freshness = sha256
       selected_identity = 0
       handshake = ClientHello
       secret_request = b
                                      SInitEarlySecretResponse
                                        session_id = session_id_cs
                             <--------- secret_list = binder_key

   To complete to the ServerHello exchange, the TLS server needs the
   handshake and application secrets.  These secrets are requested via
   an s_hand_and_app_secret LURK exchange.

   The SHandAndAppSecretRequest structure carries a tag with its
   last_exchange set to False to indicate the willingness of the TLS
   server to keep the session open and proceed to further LURK
   exchanges.  In our case, this could mean the TLS server expects to
   request additional tickets.  The session_id is set to session_id_cs,
   the value provided by the CS.  ephemeral is in our case set the
   ephemeral_method to cs_generated as described in Appendix A.1.  The
   method (x25519) to generate the (EC)DHE is indicated in the
   handshake.  The necessary handshake to derive the handshake and
   application secrets, as well the requested secrets are indicated in
   the secret_request structure.

   CS sets its tag.last_exchange to True to indicate the session will be
   closed after this exchange.  This also means that no ticket will be
   provided by the CS.  CS returns the (EC)DHE public key as well as
   requested secrets in a SHandAndAppResponse structure similarly to
   what is being described in {sec:ex:srv:ecdhe}.









Migault                  Expires 18 August 2022                [Page 50]

Internet-Draft                LURK/TLS 1.3                 February 2022


 TLS server
 LURK client                              Cryptographic Service
   SHandshakeAndAppRequest
     tag.last_exchange = False
     session_id = session_id_cs
     ephemeral
       ephemeral_method = cs_generated
     handshake = ServerHello(x25519) ... EncryptedExtensions
     secret_request = h_c, h_s, a_c, a_s ------->
                                    SHandAndAppResponse
                                      tag.last_exchange = True
                                      session_id = session_id_tls_server
                                      ephemeral
                                        key
                                          group = x25519,
                                          key_exchange = public_key
                           <--------- secret_list

A.4.  TLS client unauthenticated ECDHE

   This section details the case where a TLS client establishes a TLS
   session authenticating the TLS server using ECDHE.  The TLS client
   interacts with CS in order to generate the (EC)DHE private part.
   While this section does not illustrates session resumption, the TLS
   client is configured to proceed to session resumption which will be
   described with further details in Appendix A.5.

   The TLS handshake described in [RFC8446] is depicted below.  In this
   example, the TLS client proposes a key_share extension to agree on a
   (EC)DHE shared secret, but does not propose any PSK.

 TLS client                                   TLS Server

   Key  ^ ClientHello
   Exch | + key_share
        v + signature_algorithms --------->
                                            ServerHello  ^ Key
                                            + key_share  v Exch
                                  {EncryptedExtensions}    Server Params
                                          {Certificate}  ^
                                    {CertificateVerify}  | Auth
                                             {Finished}  v
                         <--------  [Application Data*]
     {Finished}              -------->
     [Application Data]      <------->  [Application Data]






Migault                  Expires 18 August 2022                [Page 51]

Internet-Draft                LURK/TLS 1.3                 February 2022


   If the TLS client generates the (EC)DHE private key, no interaction
   with CS is needed as it will have the default PSK value as well as
   the (EC)DHE shared secrets necessary to proceed to the key schedule
   described in section 7.1 of [RFC8446].

   In this example, the TLS client requests CS via a c_init_client_hello
   to generate the (EC)DHE private key and provide back the public part
   that will be placed into the key_share extension before being sent to
   the TLS server.

   Like in any init methods, the TLS client indicates with
   session_id_tls_client the idnetifier of the session that is being
   assigned by the TLS client for future inbound LURK message responses
   sent by the CS.  Similarly, CS advertises its session_id_cs.
   freshness is set to sha256, and the ClientHello.random is generated
   as described in Section 4.4.  handshake contains the ClientHello
   message to which the key_exchange of the KeyShareentries has been
   stripped off without changing the other fields.  As PSK are not
   involved, no early secrets are involved and c_psk_list and
   secret_request are empty.

   CS provides the KeyShareEntries.  The TLS client is able to build the
   ClientHello to the TLS server with ClientHello.random and by placing
   the KeyShareEntries.

  TLS client
  LURK client                              Cryptographic Service
    CInitClientHello
      session_id = session_id_tls_client
      freshness = sha256
      ephemeral
        ephemeral_method = cs_generated
      handshake = ClientHello(x25519, x488, ... )
      c_psk_id_list = []
      secret_request = []    ------>
                                     CInitClientHello
                                       session_id=session_id_cs
                                       ephemeral_list
                                         key
                                           group = x25519,
                                           key_exchange = public_key
                                         ephemeral_method = cs_generated
                                         key
                                           group = x488,
                                           key_exchange = public_key
                                       secret_list=[]





Migault                  Expires 18 August 2022                [Page 52]

Internet-Draft                LURK/TLS 1.3                 February 2022


   Upon receiving the response from the TLS server, responds with a
   ServerHello followed by additional encrypted messages.

   The TLS client needs the handshake secrets to decrypt these encrypted
   messages and send back the client Finished message.  In addition, the
   TLS client requests the application secrets to encrypt and decrypt
   the TLS session.  The secrets are requested via a
   c_hand_and_app_secret.

   We assume the TLS client supports session resumption so, the
   tag.last_exchange is unset.  The session_id takes the value
   advertises by each party during the previous c_init_client_hello
   exchange.  Since CS already has the (EC)DHE private keys, it will be
   able to derive the (EC)DHE shared secret and no information needs to
   be provided by the TLS client.  As a result, ephemeral_method is set
   to no_secret.  The handshake is composed of the messages sent by the
   TLS server.  As the TLS client does not have yet the messages are not
   decrypted, and are provided encrypted.  The requested secrets are the
   handshake and application secrets.

   CS generates the handshake secrets and the associated key to decrypt
   the encrypted messages.  As no CertificateRequest has been found, CS
   does not compute the signature that would authenticate the TLS
   client.  In this section, we assume CS is ready to accept further
   exchanges, and in our case the c_register_tickets exchange to enable
   session resumption.  Since session resumption is enabled, CS computes
   the Finished message to generate the resumption_master_secret.

   CS returns the response by unsetting the tag.last_exchange and
   cert_request.  The ephemeral is an empty list and secret_request
   returns the requested secrets.

TLS client
LURK client                              Cryptographic Service
  CHandAndAppSecretRequest
    tag.last_exchange=False
    session_id=session_id_cs
    ephemeral
      ephemeral_method = no_secret
    handshake = ServerHello, {EncryptedExtensions}...,{Finished}.
    secret_request = h_c, h_s, a_c, a_s ------->
                                   CHandAndAppSecretResponse
                                     tag
                                       last_exchange=False
                                        cert_request=False
                                     session_id=session_id_tls_clt
                                     ephemeral_list = []
                                     secret_request = h_s, h_c, a_s, and a_c



Migault                  Expires 18 August 2022                [Page 53]

Internet-Draft                LURK/TLS 1.3                 February 2022


   Upon reception of the response, the TLS client generates the
   necessary keys to decrypt and encrypt the handshake message and
   terminates the TLS handshake.  The TLS client is also able to decrypt
   and encrypt application traffic.

   In this section, we assume that after some time, the TLS client
   receives a NewSessionTicket from the TLS server.  The TLS client will
   then transmit the NewSessionTicket to CS so that it can generate the
   associated PSK that will be used for the authentication.

   As multiple NewSessionTickets may be sent, in this example, both TLS
   client and CS enable further additional registrations by unsetting
   tag.last_exchange.  For each registered NewSessionTicket, CS returns
   c_spk_id that will use for further references.  The c_spk_ids are
   managed by CS which can ensure the uniqueness of these references as
   opposed to using the ticket field that is assigned by the TLS server.

   Appendix A.5 illustrates how session resumption is performed using
   PSK / PSK-ECDHE authentication.

   TLS client
   LURK client                              Cryptographic Service
     RegisterTicketsRequest
       tag.last_exchange=False
       session_id=session_id_cs
       ticket_list = [NewSessionTicket]
                   ---------------->
                                      RegisterTicketsResponse
                                        last_exchange=False
                                        session_id=session_id_tls_clt
                              <-------- c_spk_id_list = [nst_id]

A.5.  TLS client unauthenticated PSK / PSK-ECDHE

   This section describes the intercation between a TLS client and a CS
   for a PSK-ECDHE TLS handshake.  Appendix A.4 shows how the PSK may be
   provisioned during a ECDHE TLS handshake.  The scenario described in
   this section presents a number of similarities to the one described
   in Appendix A.4.  As such, we expect the reader to be familiar with
   Appendix A.4 and will highlight the differences with Appendix A.4 to
   avoid to repeat the description.

   In this section, the PSK is protected by the CS, but the (EC)DHE
   private keys are generated by the TLS client and as such are
   considered as unprotected.  As the (EC)DHE secret are generated by
   the TLS client, the ephemeral_method is set to no_secret, and the
   key_share extension is fully provided in the ClientHello.  However,
   the ClientHello do not carry the PreSharedKeyExtension.  Instead,



Migault                  Expires 18 August 2022                [Page 54]

Internet-Draft                LURK/TLS 1.3                 February 2022


   this extension is built from the NewSessionTicket identifier nst_id
   provided in our case from a previous c_register_ticktes exchange (see
   Appendix A.4 }.  The TLS client requests the binder_key associated to
   nst_id in order to be able to complete the binders.

   Upon receiving the message, the CS, computes the binder_keys,
   complete the ClientHello in order to synchronize its TLS handshake
   with the TLS client (and the TLS server).  As CS does not generate
   any (EC)DHE, the ephemeral_list is empty.

   TLS client
   LURK client                              Cryptographic Service
     CInitClientHello
       session_id = session_id_tls_client
       freshness = sha256
       ephemeral
         ephemeral_method = no_secret
       handshake = ClientHello without PreSharedKeyExtension
       c_psk_id_list = [nst_id]
       secret_request = [b]    ------>
                                      CInitClientHello
                                        session_id=session_id_cs
                                        ephemeral_list = []
                                        secret_list=[binder_key]

   When the TLS client receives the responses from the TLS server, the
   handshake and application secrets are requested with a c_hand_and_app
   similarly to Appendix A.4.  The only difference here is that (EC)DHE
   have been generated by the TLS client and the shared secret needs to
   be provided to CS as described below:

TLS client
LURK client                              Cryptographic Service
  CHandAndAppSecretRequest
    tag.last_exchange=False
    session_id=session_id_cs
    ephemeral
      ephemeral_method = e_generated
      shared_secret
    handshake = ServerHello, {EncryptedExtensions}...,{Finished}.
    secret_request = h_c, h_s, a_c, a_s ------->
                                   CHandAndAppSecretResponse
                                     tag
                                       last_exchange=False
                                        cert_request=False
                                     session_id=session_id_tls_clt
                                     ephemeral_list = []
                                     secret_request = h_s, h_c, a_s, and a_c



Migault                  Expires 18 August 2022                [Page 55]

Internet-Draft                LURK/TLS 1.3                 February 2022


   Upon receiving the response, the TLS client proceeds similarly to the
   TLS client described in Appendix A.4.

A.6.  TLS client authenticated ECDHE

   This section provides scenarios when the TLS client is authenticated
   during the TLS handshake.  Post handshake authentication is detailed
   in Appendix A.7

A.6.1.  (EC)DHE or Proposed PSK protected by the CS

   When the (EC)DHE part have been generated by the CS, or the proposed
   PSK are protected by the CS, the TLS client sends a ClientHello after
   a c_client_hello exchange with CS (see Appendix A.5 or Appendix A.4).
   The request for TLS client authentication is indicated by a encrypted
   CertificateRequest sent by the TLS server as indicated below:

 TLS client                                   TLS Server

   Key  ^ ClientHello
   Exch | + key_share
        v + signature_algorithms --------->
                                            ServerHello  ^ Key
                                            + key_share  v Exch
                                  {EncryptedExtensions}  ^ Server Params
                                  {CertificateRequest}   v
                                          {Certificate}  ^
                                    {CertificateVerify}  | Auth
                                             {Finished}  v
                         <--------  [Application Data*]
        ^ {Certificate}
   Auth | {CertificateVErify}
        v {Finished}              -------->
          [Application Data]      <------->  [Application Data]

   The TLS client is unaware of the presence of the CertifcateRequest
   until it has decrypted the message with a key derived from the
   handshake secrets.  As a result, the TLS client initiates a
   c_hand_an_app_secret exchange as described in Appendix A.5 or
   Appendix A.4.

   CS proceeds as described in Appendix A.5 or Appendix A.4.  However,
   after the messages have been decrypted, CS proceeds to the generation
   of the signature and returns the necessary information to build the
   CertificateVerify.  CS indicates their presence by setting
   tag.cert_request and returns the certificate, the sig_algo and sig as
   described below:




Migault                  Expires 18 August 2022                [Page 56]

Internet-Draft                LURK/TLS 1.3                 February 2022


TLS client
LURK client                              Cryptographic Service
  CHandAndAppSecretRequest
    tag.last_exchange=False
    session_id=session_id_cs
    ephemeral
      ephemeral_method = e_generated
      shared_secret
    handshake = ServerHello, {EncryptedExtensions}...,{Finished}.
    secret_request = h_c, h_s, a_c, a_s ------->
                                   CHandAndAppSecretResponse
                                     tag
                                       last_exchange=False
                                       cert_request=True
                                     session_id=session_id_tls_clt
                                     ephemeral_list = []
                                     secret_request = h_s, h_c, a_s, and a_c
                                     certificate
                                       certificate_type = finger_print
                                     sig_algo = ed25519
                                     sig

   Note that in the example above, (EC)DHE have not been generated by
   the CS, but the c_client_hello was motivated to propose a protected
   PSK.  As the PSK has not been agreed for authentication by the TLS
   server, the TLS session does not provide PFS and the protection is
   similar as the one described in {sec:ex:clt:auth:ecdhe-certverify},
   where the TLS client would have proposed directly ECDHE with (EC)DHE
   generated by the TLS client.

A.6.2.  (EC)DHE provided by the TLS client

   This section considers a TLS client that proposes to authenticate the
   TLS server using ECDHE with (EC)DHE private parts being generated by
   the TLS client.
















Migault                  Expires 18 August 2022                [Page 57]

Internet-Draft                LURK/TLS 1.3                 February 2022


   The TLS client does not need to interact with CS to build its
   ClientHello.  Similarly, as the (EC)DHE private part have been
   generated by the TLS client, the TLS client is able to perform the
   key schedule and derive the necessary keys to decrypt the encrypted
   response from the TLS server.  Upon receiving a CertificateRequest,
   the TLS client requests CS to generate the signature needed to send
   the CertificateVerify.  The exchange is very similar as the one
   s_init_cert_verify (see Appendix A.1.2).  As the (EC)DHE shared
   secret is generated by the TLS client, the ephemeral_method is
   necessarily set to e_generated.  The handshake is set to the
   ClientHello ... server Finished, and the certificate carries the
   reference to the TLS client certificate, so CS picks the appropriated
   private key.  sig_algo designates the signature algorithm.

   TLS server
   LURK client                              Cryptographic Service
     CInitCertVerifyRequest
       tag.last_exchange=True   -------->
       freshness = sha256
       ephemeral
         ephemeral_method = e_generated
         key
           group = x25519
           shared_secret = shared_secret
       handshake = hanshake
       certificate
         certificate_type = finger_print
       sig_algo = ed25519
                                      CInitCertVerifyResponse
                                        tag.last_exchange=True
                                        signature = sig
                                      <---------

A.7.  TLS client authenticated - post handshake authentication

   Post handshake authentication may be requested at any time after the
   TLS handshake is completed as long as the TLS client has indicated
   its support with a post_handshake_authentication extension.

   If the establishment of the TLS session did not required any
   interactions with the CS, post handshake authentication is performed
   with a c_init_post_hand_auth exchange as described in Appendix A.7.1.
   When the TLS handshake already required some interactions with CS the
   post handshake authentication is performed using a c_post_hand_auth
   described in {sec:ex:clt:auth:post_continued}.






Migault                  Expires 18 August 2022                [Page 58]

Internet-Draft                LURK/TLS 1.3                 February 2022


   In some cases, both c_init_post_hand_auth and c_post_hand_auth can be
   used.  When this is possible, c_post_hand_auth is preferred as the
   handshake context is already being provisioned in the CS.  On the
   other hand, when the shared secret is only known to the CS,
   c_init_post_hand_auth cannot be used instead.

A.7.1.  Initial Post Handshake Authentication

   This situation describes the case where the TLS client has performed
   the TLS handshake without interacting with the CS.  As a result, if
   involved PSK, (EC)DHE shared secrets are unprotected and hosted by
   the TLS client.  Upon receiving a CertificateRequest, the TLS client
   sends session_id and freshness to initiate the LURK session.
   tag.last_exchange is set in order to accept future post handshake
   authentication request.  ephemeral_method is set to secret_provide as
   CS is unable to generate the (EC)DHE shared secret.  handshake is set
   to the full handshake including the just received CertificateRequest
   message.  The certificate represents the TLS client certificate to
   determine the private key involved in computing the signature.
   sig_algo specifies the signature algorithm.

   TLS server
   LURK client                              Cryptographic Service
     CInitPostHandAuthRequest
       tag.last_exchange = False
       session_id = session_id_tls_client
       freshness = sha256
       ephemeral
         ephemeral_method = e_generated
       handshake = ClientHello ... client Finished CertificateRequest
       certificate
         certificate_type = finger_print
        sig_algo   ---------------->
                                      CInitPostHandAuthResponse
                                        tag.last_exchange = False
                                        session_id = session_id_cs
                      <--------------   signature = sig

A.7.2.  Post Handshake Authentication

   In this scenario, the post authentication is performed while a LURK
   session has already been set.  Upon receiving the CertificateRequest,
   the TLS client proceeds similarly to the initial post handshake
   authentication as described in As a result, the exchange is
   illustrated below:Appendix A.7.1 except that the LURK session does
   not need to be initiated, the shared secret is already known to CS
   and the handshake is only constituted of the remaining
   CertificateRequest message.



Migault                  Expires 18 August 2022                [Page 59]

Internet-Draft                LURK/TLS 1.3                 February 2022


   TLS server
   LURK client                              Cryptographic Service
     CInitPostHandAuthRequest
       tag.last_exchange = False
       session_id = session_id_tls_client
       handshake = CertificateRequest
       certificate
         certificate_type = finger_print
        sig_algo   ---------------->
                                      CInitPostHandAuthResponse
                                        tag.last_exchange = False
                                        session_id = session_id_cs
                      <--------------   signature = sig

Author's Address

   Daniel Migault
   Ericsson
   8275 Trans Canada Route
   Saint Laurent, QC  4S 0B6
   Canada

   Email: daniel.migault@ericsson.com




























Migault                  Expires 18 August 2022                [Page 60]
