---
title: LURK Extension version 1 for (D)TLS 1.3 Authentication
abbrev: LURK/TLS 1.3
docname: draft-mglt-lurk-tls13-00


area: Security
wg: LURK
kw: Internet-Draft
cat: std

coding: us-ascii
pi:
  rfcedstyle: yes
  toc: yes
  tocindent: yes
  sortrefs: yes
  symrefs: yes
  strict: yes
  comments: yes
  inline: yes
  docmapping: yes

author:
      -
        ins: D. Migault
        name: Daniel Migault
        org: Ericsson
        street: 8275 Trans Canada Route
        city: Saint Laurent, QC
        code: 4S 0B6
        country: Canada
        email: daniel.migault@ericsson.com


--- abstract

This document describes the LURK Extension 'tls13' which enables
interactions between a LURK Client and a LURK Server in a context of
authentication with (D)TLS 1.3.

--- middle


# Introduction {#sec-intro}

This document defines a LURK extension for TLS 1.3 {{!RFC8446}}. 

This document assumes the reader is familiar with TLS 1.3 the LURK
architecture {{?I-D.mglt-lurk-lurk}}. 

The motivations for the LURK Extension TLS 1.3 are similar to those for
the LURK extension of TLS 1.2 {{?I-D.mglt-lurk-tls12}} and the LURK use
cases {{?draft-mglt-lurk-use-cases}}.   

Interactions with the Cryptographic Service can be performed by the TLS
Client as well as by the TLS Server. 

LURK defines an interface to a Cryptographic Service that stores the
security credentials. These credentials are
typically involved in authentication messages and include the PSK used
in a PSK or PSK-ECDHE authentication or the key
used for signing  in an ECDHE authentication. As in the case of session
resumption the PSK is derived from the resumption_master_secret during
the key schedule {{!RFC8446}} section 7.1, these secret requires similar
protection as well.

# Protocol overview

This document describes the interactions between a LURK client and a
Cryptographic Service. Both of them can be hosted on a TLS server or a
TLS client.

The purpose of the Cryptographic Service is to provide the LURK the
necessary material to complete the handshake while protecting the
security credentials. The necessary material includes the different
secrets generated by the key schedule of {{!RFC8446}} section 7.1 as
well as signing operations. Secrets are generated on partial
Handshake Context, and are necessary to mov ethe TLS handshake forward.
As a result, secrets and signing operations are requested at various
point in the TLS Handshake.  

This is a major change to TLS 1.2 where all necessary information could
be retrieved in one exchange. In addition to multiple exchanges, this
requires the management of a sequence of exchanges between the Lurk
client and the Cryptographic Service. 





# LURK Header {#sec-lurk-tls-header}

LURK / TLS 1.3 is a LURK Extension that introduces a new designation
"tls13". This document assumes that Extension is defined with
designation set to "tls13" and version set to 1. The LURK Extension
extends the LURKHeader structure defined in {{?I-D.mglt-lurk-lurk}} as
follows:

~~~
enum {
    tls13 (2), (255)
} Designation;

enum {
   capabilities(0), ping(1), binder_key(2),
   early_secrets(3), handshake_and_app_secrets(4),
   handshake_secrets(5), app_secrets(6), init_certificate_verify(7),
   certificate_verify(8), post_handshake(9),
   new_session_ticket(10), register_session_ticket(11) (255)
}TLS13Type;


enum {
    // generic values reserved or aligned with the
    // LURK Protocol
    request (0), success (1), undefined_error (2),
    invalid_payload_format (3),

    invalid_psk
    invalid_freshness_funct
    invalid_h_opaque
    invalid_ctx_type

    invalid_request
    invalid_key_id_type 
    invalid_key_id 
    invalid_signature_scheme
    invalid_certificate_type
    invalid_certificate
    invalid_certificate_verify
    invalid_key_request

}TLS13Status

struct {
     Designation designation = "tls13";
     int8 version = 1;
} Extension;

struct {
    Extension extension;
    select( Extension ){
        case ("tls13", 1):
            TLS13Type;
    } type;
    select( Extension ){
        case ("tls13", 1):
            TLS13Status;
    } status;
    uint64 id;
    unint32 length;
} LURKHeader;
~~~


# Exchange Description 

The sequence of exchanges between the LURK client and the Cryptographic
Service is determine by the policies of the TLS client and the TLS
server. The policies on the TLS client will determine the proposed
capabilities to the TLS server, such policies will be reflected on
Cryptographic Service in term of necessary secrets and signing
operations to implement such capabilities. The requests of secrets or
signing operation determine the specific exchanges. Similarly, on the
TLS server side, the TLS server policies takes the TLS client
capabilities as inputs and determines the necessary secrets and signing
operations to implement such policies. As for the TLS client, the
various combination of necessary secrets and signing operations
determines the exchanges between the LURK client and the Cryptographic
Service. 

The Cryptographic Service is not expected to perform any policies such
as choosing the appropriated authentication method. Such choices are
performed by the LURK client. We expect that the logic of the LURK
client by solely configured by the security credentials and the
following parameters:

role:
defines if LURK exchanges happen on a TLS client (client) or a TLS
server (server). 

session_resumption:
is optional and is set when the TLS server provides session resumption
or when the TLS client wants to perform session resumption. By default
it is set. The motivation for having this parameter is to prevent the
Cryptographic Service to deal with NewSessionTickets when no session
resumption is used. 

delegation:
is optional and is set when the TLS server is able to perform session
resumption on behalf of the Cryptographic Service. In such case, the TLS
Server is able to retrieve the resumption_master_secret. Such
configuration prevents the Cryptographic Service to be accountable and
is thus NOT REOMMENDED. The default value is unset. When set deployment
need to carefully consider the necessary implications. 


LURK exchanges falls into three categories: 1) request of keys or
secrets, 2) request of signing operations, and 3) NewSessionTicket
management. In some cases, these operations are combined into a single
request. The table below summarizes the operations associated for each
exchange.

~~~
+--------+--------------------------+------------------------+
|  Role  | LURK exchange            | secret | sign | ticket |
+--------+--------------------------+------------------------+
| server | early_secret             | yes    |  -   |  -     |
| server | init_certificate_verify  | yes    | yes  |  -     |
| server | handshake_and_app_secret | yes    |  -   |  -     | 
| server | new_session_ticket       | yes    |  -   |  yes   |
| client | binder_key               | yes    |  -   |  -     |
| client | early_secret             | yes    |  -   |  -     | 
| client | handshake_secret         | yes    |  -   |  -     |
| client | app_secret               | yes    |  -   |  -     |   
| client | certificate_verify       | yes    | yes  |  -     |
| client | register_session_ticket  | yes    |  -   |  yes   |
| client | post_handshake           |  -     | yes  |  -     |
+--------+--------------------------+------------------------+
~~~


This section describes structures that are widely re-used across the
multiple LURK exchanges. 
* key_request that indicates which key or secret is requested. 
* secrets that provides the requested secret or key
* handshake_context used to provide the necessary Handshake Context for
both generating secrets and signing operations. 

This section also describes sub-exchanges highly reused acroos teh
various LURK exchanges:
* Key Schedule Context sub-exchange that enables to coordinate all
exchanges. 
* Ephemeral sub-exchange that enables to exchange the ECDHE value
between the LURK client and teh Cryptographic Service.
* Secret sub-exchange that enables to request a list of secrets of keys
* Signature sub-exchange that enables the request of a signature.



~~~

enum { psk_id(1), ephemeral(2) };
    struct {
        ExtensionType extension_type;
        opaque extension_data<0..2^16-1>;
    } Extension
~~~


## key_request {#sec:key_request}

key_request is a 16 bit structure described in Table
{{table:key_request_struct}} that indicates the requested key or secrets
by the LURK client. The same structure is used across all LURK
exchanges, but each LURK exchange only permit a subset of values
described in Table {{table:key_request_values}}.

A LURK client MUST NOT set key_request to key or secrets that are not
permitted. The Cryptographic Service MUST check the key_request has only 
permitted values and has all mandatory key or secrets set. If these two
criteria are not met the Cryptographic Service MUST NOT perform the LURK
exchange and SHOULD return a invalid_key_request error. If the
Cryptographic Service is not able to to compute an optional key or
secret, the Cryptographic Service MUST proceed the LURK exchange and
ignore the optional key or secret. 



~~~
+------+-------------------------------------------+
| Bit  |      key or secret     (designation)      |
+------+-------------------------------------------+
| 0    | binder_key (b)                            |
| 1    | client_early_traffic_secret (e_s)         |
| 2    | early_exporter_master_secret (e_x)        |
| 3    | client_handshake_traffic_secret (h_c)     |
| 4    | server_handshake_traffic_secret (h_s)     |
| 5    | client_application_traffic_secret_0 (a_c) |
| 6    | server_application_traffic_secret_0 (a_s) |
| 7    | exporter_master_secret (x)                |
| 8    | resumption_master_secret (r)              |
| 9-15 | reserved and set to zero                  |
+------+-------------------------------------------+
~~~
{: #table:key_request_struct title="key_request structure" }

~~~
+--------+--------------------------+--------------------------+
|  Role  | LURK exchange            | Permitted key/secrets    |
+--------+--------------------------+--------------------------+
| server | early_secret             | b,e_c*, e_x*             |
| server | init_certificate_verify  | h_c, h_s, a_c*, a_s*, x* |
| server | handshake_and_app_secret | h_c, h_s, a_c*, a_s*, x* | 
| server | new_session_ticket       | r*                       |
| client | binder_key               | b                        |
| client | early_secret             | e_c*, e_x*               | 
| client | handshake_secret         | h_c, h_s                 |
| client | app_secret               | a_c*, a_s*, x*           | 
| client | certificate_verify       | a_c*, a_s*, x*           |
| client | register_session_ticket  | r*                       |
| client | post_handshake           |                          |
+--------+--------------------------+--------------------------+

(*) indicates an optional value, other values are mandatory
~~~
{: #table:key_request_value title="key_request permitted values per LURK
exchange" }

## secrets {#sec:secrets}


The Secret structure carries a secret designated by its type and value. 

~~~
enum {
    binder_key (0),
    client_early_traffic_secret(1),
    early_exporter_master_secret(2),
    client_handshake_traffic_secret(3),
    server_handshake_traffic_secret(4),
    client_application_traffic_secret_0(5),
    server_application_traffic_secret_0(6),
    exporter_master_secret(7), 
    esumption_master_secret(8),
    (255)
} SecretType;

struct {
    SecretType secret_type;
    opaque secret_data<0..2^8-1>;
} Secret;
~~~

secret_type:
The type of the secret or key

secret_data:
The value of the secret.


## handshake_context {#sec:handshake_context}

Secrets derivation takes Handshake Context as input. It is the
responsibility of the Cryptographic Service to maintain this variable in
an internal variable. On the other hand it is the responsibility of the
LURK client to provide the necessary element so the Cryptographic
Service got the necessary Handshake Context. The Handshake Context
evolves during the key derivation schedule, the LURK client implement a
incremental approach were only the missing part of the Handshake Context
are provided. The main intention is to prevent the LURK client from
providing multiple time the same information as well as to perform
extensive compatibility checks between the duplicated information
provided.

The handshake_context variable is based on the Handshake structure
defined in {{!RFC8446}} section 4. The table below lists the values
of the handshake_context associated to each LURK exchange.  

~~~
+--------+--------------------------+----------------------------------+
|  Role  | LURK exchange            |   handshake_context              |
+--------+--------------------------+----------------------------------+
| server | early_secret             | ClientHello                      |
| server | init_certificate_verify  | ClientHello ... later of         |
|        |                          | server EncryptedExtensions /     |
|        |                          | CertificateRequest               |
| server | handshake_and_app_secret | ServerHello ... later of         |
|        |                          | server EncryptedExtensions /     |
|        |                          | CertificateRequest               |
| server | new_session_ticket       | earlier of client Certificate    |
| client | binder_key               |                                  |
| client | early_secret             | ClientHello                      |  
| client | handshake_secret         | ClientHello ... ServerHello or   |
|        |                          | ServerHello (after early_secret) |
| client | app_secret               | server EncryptedExtensions ...   |
|        |                          | server Finished                  |
| client | certificate_verify       | server EncryptedExtensions ...   |
|        |                          | later of server Finished/        |
|        |                          | EndOfEarlyData                   | 
| client | register_session_ticket  | earlier of client Certificate    |
|        |                          | client CertificateVerify ...     |
|        |                          | client Finished                  |
| client | post_handshake           | CertificateRequest               |
+--------+--------------------------+----------------------------------+
~~~

When implemented on the TLS client, handshake_secret LURK exchange the
handshake_context is ClientHello ... ServerHello when it is an initial
LURK exchange. Otherwise, it follows a early_secret LURK exchange in
which case the provided handshake_context is ServerHello.  


## Secret Sub Exchange (#sec:secret}

Secrets are derived from the key schedule of {{!RFC8446}} section 7.

The derivation of secrets requires an optional PSK that is provided in
the psk_id extension as well as a ECDHE value which is provided by the
ecdhe extension. 



~~~
struct {
    uint16 key_request;
    Handshake handshake_context<0..2^32> //RFC8446 section 4.
    Extension extention_list<0...2^16>
} SecretsRequest;


struct {
    Secret secret_list<0..2^16-1>;
    Extension extention_list<0...2^16>
} SecretsResponse;

~~~

key_request:
designates the requested secrets (see section {{sec:key_request}}).

handshake_context: 
designates the necessary messages so the Cryptographic Service is aware
of the appropriated Handshake Context to generate the secrets (see
section {{sec:handshake_context}}).

extension_list:
the list of extensions. 

secret_list:
the list of requested secrets (see section {{sec:secrets}}.



### Ephemeral Extension {#sec:ephemeral}

The Ephemeral structure carries the necessary
information to generate the ECDHE input used to derive the secrets.
Multiple ways are envisioned to generate the ECDHE value:

secret_provided:
The LURK client MAY provide its secret value to the
Cryptographic Service. In the case, the ephemeral extention MUST be
provided. In this case the ECDHE value is derived using the
public value of the peer read from Handshake Context. The Cryptographic
MUST NOT return any data. 

secret_generated:
The LURK client MAY request the Cryptographic Service to generate the
secret value, in which case only the public value would be returned to
the LURK client, which in turn would transmit it to the other peer. The
indication of a generated secret is performed by omitting the extension.
The Cryptographic Service MUST return an Ephemeral extension with the
associated public values, using a KeyShareEntry as defined in section
4.2.8 of {{!RFC8446}}.

Other methods may be defined in the future. 

This extension MUST NOT be sent outside the LURK exchanges mentioned
below. * indicates that the extension is acceptable. When received
outside these exchanges, the Cryptographic Service SHOULD return an
invalid_extension error. When the ephemeral is not supported, an
invalid_ephemeral error SHOULD be returned.  

~~~
+--------+--------------------------+------------+
|  Role  | LURK exchange            | Acceptable |
+--------+--------------------------+------------+
| server | early_secret             |    -       |
| server | init_certificate_verify  |    *       |
| server | handshake_and_app_secret |    *       | 
| server | new_session_ticket       |    -       |
| client | binder_key               |    -       |
| client | early_secret             |    -       | 
| client | handshake_secret         |    *       |
| client | app_secret               |    -       | 
| client | certificate_verify       |    *       |
| client | register_session_ticket  |    -       |
| client | post_handshake           |    -       |
+--------+--------------------------+------------+
~~~

TODO: check for on the TLS client side. 

The extension data is defined as follows:
~~~

enum { secret_provided(0), secret_generated(1) (255)};

EphemeralData{
    uint8 method
    opaque secret<0..2^32> 
}
~~~
 

### PSK Extension

The psk_id indicates the identity of the PSK used in the key schedule.

The LURK client MUST NOT provide this extension outside the
early_secret, binder_key. When receiving the PSK extension outside these
messages, teh Cryptographic Service MUST NOT proceed to the exchange and
SHOULD return a invalid_format error.  

~~~
+--------+--------------------------+------------+
|  Role  | LURK exchange            |  Permitted |
+--------+--------------------------+------------+
| server | early_secret             |    *       |
| server | init_certificate_verify  |    -       |
| server | handshake_and_app_secret |    -       | 
| server | new_session_ticket       |    -       |
| client | binder_key               |    *       |
| client | early_secret             |    -       | 
| client | handshake_secret         |    -       |
| client | app_secret               |    -       | 
| client | certificate_verify       |    -       |
| client | register_session_ticket  |    -       |
| client | post_handshake           |    -       |
+--------+--------------------------+------------+
* indicates the extension MAY be provided 
~~~
~~~
PskIdentity psk_id; //RFC8446 section 4.2.11
~~~

Upon receiving this extension in the permitted LURK exchange the
Cryptographic Service checks the PSK is available. In case the PSK is
not available, an invalid_psk error is returned. If the PSK is not
provided, a default PSK is generated as described in {{!RFC8446}}
section 7.1. If the default PSK is not allowed then an invalid PSK is
returned. 

### Freshness_funct Extension

The freshness_function provides perfect forward secrecy (PFS) and is
used by the LURK client on the TLS client to generate the
ClientHello.random or by the LURK client on the TLS server to generate
the ServerHello.random. When these randoms are provided to the
Cryptographic Service, the freshness_function MUST be provided as well.

Table {{table:freshness}} lists the LURK exchange that MUST include the
freshness function extension as well as those where the extension may be
provided. The handshake_secret LURK exchange on the TLS client MUST have
the freshness_function extension if a ClientHello is carried. Otherwise
the extension MUST NOT be provided.   

~~~
+--------+--------------------------+------------+
|  Role  | LURK exchange            |  Presence  |
+--------+--------------------------+------------+
| server | early_secret             |    -       |
| server | init_certificate_verify  |    M       |
| server | handshake_and_app_secret |    M       | 
| server | new_session_ticket       |    -       |
| client | binder_key               |    -       |
| client | early_secret             |    M       | 
| client | handshake_secret         |    *       |
| client | app_secret               |    -       | 
| client | certificate_verify       |    -       |
| client | register_session_ticket  |    -       |
| client | post_handshake           |    -       |
+--------+--------------------------+------------+
* indicates the extension MAY be provided 
M indicates the extension is mandatory
- indictaes the extension MUST NOT be provided
~~~

~~~
PFSAlgorithm freshness_funct;  // {{!I-D.mglt-lurk-tls12}} section 4.1
~~~


If the Cryptographic Service does not support the freshness_funct, an
invalid_freshness_funct error is returned.


Perfect forward secrecy is implemented in a similar manner as with the
TLS 1.2 extension described in {{?draft-mglt-lurk-tls12}} section 4.1.1.
As ServerHello.random in TLS 1.3 do not include time, it is not
considered here. In addition, we use a specific context related to TLS
1.3. 

As a result, the ServerHello.random is generated as follows on the TLS
server. 

~~~
ServerHello.random = freshness_funct( server_random + "tls13 pfs srv" );
~~~

The ClientHello.random is generated as follows on the TLS client side:

~~~
ClientHello.random = freshness_funct( server_random + "tls13 pfs clt" );
~~~


Perfect forward secrecy applies to the ServerHello.random on the TLS
server and on the ClientHello.random on the TLS client. As a result, PFS
is provided on the TLS server as long as the ServerHello is part of the
Handshake Context. Similarly PFS is provided on the TLS client as long
as ClientHello is part of the Handshake Context. On the TLS server,
early_secret exchange do not have the ServerHello so this exchange is
not protected by PFS later exchanges are. On teh TLS client side,
binder_key does not have any Handshake Context so this exchange is not
protected by PFS. Later exchanges are. 

## Context Agreement Sub-Exchange {sec:ctx_agreeemnet}

The LURK client and the Cryptographic Service performs an ordered
sequence of LURK exchange in order to complete a TLS handshake. This
serie of LURK exchange is performed within a session identified by a
session_id on both side. Each side uses a specific session_id used for
inbound traffic. In addition, a cookie mechanisms provides means to
ensure that the suite of LURK messages come from the same LURK client.

The management of this session is managed via a key schedule context
(ks_ctx). This context contains the session_id used for inbound traffic,
the session_id used for the outbound traffic as well as the necessary
cryptographic material to generate the cookies (cookie_h).    

ContextAgreementRequest and ContextAgreementResponse are present in
all LURK exchange initiating a session as represented in Table
{{table:ctx_agreement}}. It is present in the handshake_secret LURK
exchange when this exchange initiates a session, otherwise it is
omitted.  

The structure is represented below:
~~~
struct {
    PFSAlgorithm cookie_h; //{!I-D.mglt-lurk-tls12}} section 4.1
    unint32 lurk_client_session_id;
    unint32 lurk_client_cookie_init;
} ContexAgreementRequest;

struct {
    uint32 crypto_service_session_id
    uint32 crypto_service_cookie_init
} ContextAgreementResponse
~~~

cookie_h:
The hash fucntion used to generate the cookies througout the session. 

lurk_client_session_id:
the session_id used by the LURK client. Packets from the Cryptographic
Service to the LURK client are expected to have this value as
session_id. The session_id MUST be generated randomly for each session.

lurk_client_cookie_init:
A random value that charcterizes the exchange and that is not visible in
the next LURK exchange of the session.

crypto_service_session_id:
the session_id used by the Cryptographic Servce. Packets from the LURK
client to the Cryptographic Service are expected to have this value as
session_id. The session_id MUST be generated randomly for each session. 

crypto_service_cookie_init:
A random value that charcterizes the exchange and that is not visible in
the next LURK exchange of the session.

If the Cryptographic Service does not support cookie_h an
invalid_cookie_h error is returned. Otherwise, the Cryptographic Service
initiates a context (ks_ctx).  

The cookie mechanism is intended to prevent an attacker to perform an
exchange within a session established between the LURK client and the
Cryptographic Service. Cookies are generated as represented below by the
LURK client and the Cryptographic Service.  The cookie MUST be checked
against its expected value. When the Cryptographic Service does not
receive the expected cookie, the request is discarded or an
invalid_request error is sent.

~~~
salt_0 = LURK exchange
salt_n+1 = HKDF-Expand-Label(salt_n,
                        label, "", cookie_h.length)
cookie_n+1 = cookie_h(salt_n+1)[4]
~~~

salt_0 is initialized by the LURK exchange initating the session, i.e
the early_secret, the init_ceritficate_verify, binder_key or
handshake_secret. Next saltz are derived iteratively and the
corresponding cookie takes the 32 most significant bits of the
resultingh hash of the salt_n with cookie_h. The first cookie sent is
sent for n=1. The label is set to "cs_cookie" for request sent to the
Cryptographic Service. The resulting cookie is designated as
crypto_service_cokkie. The lable is set to "clt_cookie" for responses
sent to the LURK client. The resulting cookie is designated a
lurk_client_cookie.   

~~~
+--------+--------------------------+----------+
|  Role  | LURK exchange            | Presence |
+--------+--------------------------+----------+
| server | early_secret             | M        |
| server | init_certificate_verify  | M        |
| server | handshake_and_app_secret | -        | 
| server | new_session_ticket       | -        |
| client | binder_key               | M        |
| client | early_secret             | -        | 
| client | handshake_secret         | *        |
| client | app_secret               | -        | 
| client | certificate_verify       | -        |
| client | register_session_ticket  | -        |
| client | post_handshake           | -        |
+--------+--------------------------+----------+
* indicates the extension MAY be provided 
M indicates the extension is mandatory
- indictaes the extension MUST NOT be provided
~~~



## Signing Sub-Exchange {sec:siging}

The signature requires the signature scheme (sig_algo), the designated
private key (key_id), as well as sufficient context to generate the
necessary data to be signed. In our case the necessary context is
provided by the LURKCertificate, assuming the Cryptographic Service will
have the necessary Handshake Context. The latest may be provided in a
combination of a secret request. 

key_id is processed as described in {{?draft-mglt-lurk-tls12}} section
4.1. If the Cryptographic Service does not support the KeyPairIdType an
invalid_key_id_type is returned. If the Cryptographic Service does not
recognize the key, an invalid_key_id error is returned.  

sig_algo designates the signature algorithm scheme, and it is defined in
{{!RFC8446} section 4.2.3. When the Cryptographic Service does not
support the signature scheme an invalid_signature_scheme error is
returned. 

The certificate is a public data that may repeat over multiple distinct
TLS handsahkes. To limit the load of unnecessary information being
transmitted multiple times, the LURKCertificate enable to carry the
index of the Certificate structure rather than the structure itself.
When the lurk_certificate_type is set to sha256_32, the index of the
Certificate structure is sent. The current specification generates the
index using sha256_32 as defined in {{?draft-mglt-lurk-tls12}}, that is
the first 32 bits of the hash of the Certificate structure using SHA256
as the hashing function. When lurk_certificate_type is set to tls13 the
Certificate structure is expected. When the Cryptographic Service does
not support the certificate_type, an invalid_certificate_type error is
returned. When the Certificate structure does not match the private key,
an invalid_certificate error is returned. 

Signing operations are described in {{!RFC8446}} section 4.4.3. The
context string is derived from the role and the type of the TLS13Request
as described below. The Handshake Context is taken from the key schedule
context.   

~~~
+--------+-------------------------+-------------------------------------+
| role   | type                    | context                             |
+--------+-------------------------+-------------------------------------+
| server | init_certificate_verify | "TLS 1.3, server CertificateVerify" |
| client | certificate_verify      | "TLS 1.3, client CertificateVerify" |
+--------+-------------------------+-------------------------------------+
~~~

The Cryptographic Service computes the signature as described in
{{!RFC8446}} section 4.4.3. and returns signature in SigningResponse.
When the Cryptographic Service does not have the necessary Handshake
Context, context or is unable to proceeds to the signing operation, an
invalid_certificate_verify error is returned. 


~~~
enum { tls13(0), sha256_32(1) (255)}; LURKCertificateType

struct {
    lurk_certificate_type;
    select (lurk_certificate_type) {
        case sha256_32:
            uint32 hash_cert;
        case tls13:
            Certificate tls13_certificate; // RFC8446 section 4.4.2
    };
} LURKCertificate;




struct {
    KeyPairId key_id; // draft-mglt-lurk-tls12 section 4.1
    SignatureScheme sig_algo; //RFC8446 section 4.2.3.
    LURKCertificate certificate; 
} SigningRequest;


struct {
    opaque signature<0..2^16-1>; //RFC8446 section 4.4.3.
} SigningResponse; 
~~~

## LURK exchange on the TLS server

This section describes the LURK exchanges that are performed on the TLS
server. The state diagram is provided in section
{{sec:state_diagram_server}} 

## server: early_secret {#sec:early_secret}  


A TLS server MAY receive a ClientHello that proposes PSK or PSK-ECDHE
authentication via the pre_shared_key and psk_key_exchange_modes
extensions. Depending on its policies, the TLS server MAY decide to
proceed to such authentication. It choses a PSK identity so the LURK
client initiates a key schedule context (ks_ctx) that will manage the
session with the Cryptographic Service. This session is initiated with a
early_secret exchange. 

The binder_key MUST be requested, since it is used to validate the PSK. 

The TLS client MAY indicate support for early application data via the
early_data extension. Depending on the TLS server policies, it MAY
accept early data and request the client_early_traffic_secret. 

The TLS server MAY have specific policies and request
early_exporter_master_secret.

Upon receiving an early_secret request, the Crytographic Service
proceeds the ContextAgreementRequest as described in
{{sec:ctx_agreement}} as well as the SecretRequest as described in
section {{sec:secret}}.

The Cryptographic Service MUST check pre_shared_key and
psk_key_exchange_modes extensions are present in the ClientHello. If
these extensions are not present, a invalid_handshake error SHOULD be
returned. 
The Cryptographic Service MUST ignore the client_early_traffic_secret if
early_data extension is not found in the ClientHello. The Cryptographic
Service MAY ignore the request for client_early_traffic_secret, in any
case. The Cryptographic Service MAY ignored the request for
early_exporter_master_secret.

~~~
struct{
    ContextAgreementRequest ctx_request
    SecretRequest secret_request
} EarlySecretRequest



struct{
    ContextIDResponse ctx_response
    SecretResponse secret_response
} EarlySecretResponse

~~~

ctx_request:
The structure associated to the context agreement request defined in
section {#sec:ctx_agreement}

secret_request:
The structure associated to the secret request defined in {sec:secret} 

ctx_response:
The structure associated to the context agreement response defined in
section {#sec:ctx_agreement}

secret_response:
The structure associated to the secret request defined in {sec:secret} 



## server: init_certificate_verify {#sec:init_certificate_verify}

A TLS server MAY receive a ClientHello that proposes ECDHE
authentication with a key_share extension. Depending on its policies,
the TLS server MAY decide to proceed to such authentication and indicate
it to the LURK client so it initiates a key schedule context (ks_ctx)
that will manage the session with the Cryptographic Service. This
session is initiated with a init_certificate_verify exchange. 

The Cryptographic MUST ensure the ServerHello has selected the ECDHE
authentication that is a key_share extension is present and no
pre_shared_key extension is present. If these conditions are not met, a
invalid_handshake error SHOULD be returned. 

In order to provide generate the client_application_traffic_secret_0 and
server_application_traffic_secret_0, the Cryptographic Service generates
the server Finished. This value is computed to avoid multiple round
trips. This value is not returned to the LURK client and needs to be
computed again by the TLS server. 

After the exchange is completed, the TLS server is able to build and
return the ServeHello and complete the TLS handshake.

If the Cryptographic Service has been configured not to handle session
resumption. The session is finished and ks_ctx SHOULD be deleted and
some implementations MAY NOT create the ks_ctx. While the ctx_request
and ctx_responses MAY be ignored, their associated overhead is limited
and for sake of simplicity, we did not consider creating a different
LURK exchange. 

~~~
struct{
    ContextAgreementRequest ctx_request
    SecretRequest secret_request
    SigingRequest signing_request    
}CertificateVerifyRequest


struct{
    ContextIDResponse ctx_response
    SecretResponse secret_response
    SigningResponse signing_response
} CertificateVerifyResponse
~~~

ctx_request, ctx_response, secret_request and secret_response are
defined in section {{sec:early_secret}}.

## server: handshake_and_app_secret {#sec:handshake_and_app_secret}

The handshake_and_app_secret is necessary to complete the ServerHello
and always follows an early_secret LURK exchange. Such sequence is
guaranteed by the session_id and cookie mechanism. In case of unknown
session_id or an unexpected cookie value, an invalid_request error
SHOULD be returned. 

The LURK client MUST ensure that PSK or PSK-ECDHE authentication has
been selected via the presence of the pre_shared_key extension in the
the ServerHello. In addition, the selected identity MUST be the one
provided in the psk extension of the previous early_secret exchange.

The LURK client MAY request the exporter_master_secret depending on its
policies. The Cryptographic Service MAY ignore the request based on its
policies. 

Similarly to the init_certificate_verify, if session resumption is not
provided by the Cryptographic Service, the LURK session ends after this
exchange and ks_ctx SHOULD be removed. 

~~~
struct{
    uint32 crypto_service_session_id
    uint32 crypto_service_cookie
    SecretRequest secret_request
} HandshakeRequest



struct{
    uint32 lurk_client_session_id
    uint32 lurk_client_cookie
    SecretResponse secret_response
} HandshakeResponse

~~~
crypto_service_session_id:
value provided in the ContexAgreementResponse - see section
{{sec:ctx_agreement}}.

crypto_service_cookie:
cookie value generated as described in section {{sec:ctx_agreement}}.

lurk_client_session_id:
value provided in the ContexAgreementRequest - see section
{{sec:ctx_agreement}}.

lurk_client_cookie:
cookie value generated as described in section {{sec:ctx_agreement}}.

## new_session_tickets {#sec:new_session_ticket}}

new_session ticket handles session resumption. It enables to retrieve
NewSessionTickets that will be forwarded to the TLS client by the TLS
server to be used later when session resumption is used. It also
provides the ability to delegate the session resumption authentication
from the Cryptographic Service to the TLS server. In fact, if the LURK
client requests and receives the resumption_master_secret it is able to
emit on its own NewSessionTicket. As a result new_session_ticket LURK
exchanges are only initiated if the TLS server expects to perform
session resumption and the Cryptographic Service responds only if if
session_resumption is enabled. If session resumption is not enabled, the
Cryptographic MAY have ended the LURK session and the new_session_ticket
will be ignored or responded with a invalid_request error. 

The Cryptographic Service MAY responds with a resumption_master_secret
based on its policies. 

The LURK client MAY perform multiple new_session_ticket exchanges before
the session between the LURK client and the Cryptographic Service is in
a finished state with ks_ctx deleted. 

~~~
struct {
    uint32 crypto_service_session_id
    uint32 crypto_service_cookie
    uint8 ticket_nbr;
    unint16 key_request;
    Handshake handshake_context<0..2^32> //RFC8446 section 4.
} NewSessionTicketRequest;


struct {
    uint32 lurk_client_session_id
    uint32 lurk_client_cookie
    NewSessionTicket ticket_list<0..2^16-1>; //RFC8446 section 4.6.1.
} NewSessionTicketResponse;
~~~

crypto_service_session_id, crypto_service_cookie,
lurk_client_session_id, and lurk_client_cookie are defined in section
{{sec:handshake_and_app_secret}}. key_request is defined in section
{{sec:key_request}}. 

ticket_nbr:
designates the requested number of NewSessionTicket. In the case of
delegation this number MAY be set to zero. The Cryptographic Service MAY
responds with less tickets when the value is too high.

## LURK exchange on the TLS client

This section describes the LURK exchanges that are performed on the TLS
server. The state diagram is provided in section
{{sec:state_diagram_client}} 

## client: binder_key  

The binder_key LURK exchange is initiates a LURK session when the TLS
client is willing to propose a PSK for PSK or PSK-ECDHE authentication. 

The handshake_context is empty as the ClientHello is under construction. 

When a LURK client proposes multiple PSK, multiple binder_keys are
requested. 

The binder_key is equivalent to a secret LURK exchange and there is no
creation of a ks_ctx. 

## client: early_secret

early_secret on the TLS client side works similarly as the early_secret
LURK exchange on the TLS server as described in section
{{sec:early_secret}}. One key difference is that the binder_key is not
requested during that LURK exchange, as a result, this LURK exchange MAY
be omited even when PSK or PSK-ECDHE authentication has been chosen by
the TLS client. The early_secret will only be performed in the case of
0-RTT handshake or when early exporters are required.   

## client: handshake_secret {#handshake_secret}

The handshake_secret is performed after an early_secret LURK exchange.
This exchange is performed in the case of an PSK or PSK-ECDHE
authentication and coherence with the handshake context MUST be checked
by the LURK client as well as by the Cryptographic Service as described
in {{sec:early_secret}} and section {{sec:handshake_and_app}}. 

The structures of the handshake_secret follow those of the
handshake_and_app_secret described in section
{{handsahke_and_app_secret}}. 

## client: init_handshake_secret 

The handshake_secret LURK exchange MAY be initiating a session between
the LURK client and the Cryptographic Service in which case it contains
a ctx_agreement structures. 

Coherence between with the handshake context and the authentication
ECDHE versus PSK or PSK-ECDHE) is performed as described in section
{{sec:early_secret}} and section {{sec:handshake_and_app_secret}}. When a
ctx_agreement structure is provided, the presence a pre_shared_key
extension in the ServerHello message indicates the choice of PSK or
PSK-ECDHE authentication. The LURK client and the Cryptographic Service
MUST ensure such coherence. 

Only the client_handshake_traffic_secret_0 and
server_handshake_traffic_secret_0 secrets MAY be requested. 

~~~
struct{
    ContextAgreementRequest ctx_request
    SecretRequest secret_request
    SigingRequest signing_request    
}CertificateVerifyRequest


struct{
    ContextIDResponse ctx_response
    SecretResponse secret_response
    SigningResponse signing_response
} CertificateVerifyResponse

~~~


## client: app_secret

The app_secret LURK exchange is performed when no TLS client
authentication has been requested, i.e. CertificateRequest message is
not provided in the flight of the ServerHello. The LURK client and the
Cryptographic Service MUST ensure no CertificateRequest is present in
the handshake context.

Only the client_application_traffic_secret_0 and
server_application_traffic_secret_0 secrets MAY be requested. 

The structure follows the one of the handshake_secret described in
section {{sec:handshake_secret}}. 

After the app_secret LURK exchange, unless the TLS client supports
session resumption or post_handshake, the LURK session is finished. The
support for post_handshake by the TLS client is indicated by the
post_handshake_auth extension.

## client: certificate_verify

The certificate_verify LURK exchange is performed when TLS client
authentication has been requested by the TLS server. When performed, the
LURK client and the Cryptographic Service MUST check the presence of a
CertificateREquest structure in the handshake context. When not present,
a invalid_handshake error SHOULD be returned. 

After the app_secret LURK exchange, unless the TLS client supports
session resumption or post_handshake, the LURK session is finished. The
support for post_handshake by the TLS client is indicated by the
post_handshake_auth extension.

~~~
struct{
    uint32 crypto_service_session_id
    uint32 crypto_service_cookie
    SecretRequest secret_request
    SigingRequest signing_request    
}CertificateVerifyRequest


struct{
    uint32 lurk_client_session_id
    uint32 lurk_client_cookie
    SecretResponse secret_response
    SigningResponse signing_response
} CertificateVerifyResponse
~~~
crypto_service_session_id, crypto_service_cookie,
lurk_client_session_id, and lurk_client_cookie are defined in section
{{sec:handshake_and_app_secret}}. key_request is defined in section
{{sec:key_request}}. signing_request and signing_response are defined in
section {{sec:init_certificate_verify}}.  

## register_session_tickets

The register_session_ticket is only used when the TLS client intend to
perform session resumption. This LURK exchange has three functions. First,
it is used to register the handshake in order to provide the full TLS
handshake. Such information will be necessary to generate the PSK value
during the future session resumptions. Second, the LURK client MAY
provide one or multiple NewSessionTickets. These tickets will be
helpful for the session resumption to bind the PSK value to soem
identities. Third, the LURK client MAY retrieve the
resumption_master_secret when session resumption is being delegated by
teh Cryptographic Service to the TLS client.  

The first register_session_ticket MUST carry the TLS handshake and future
register_session_ticket LURK exchange MUST have a handshake_context of zero
length. If these conditions are not met, the Cryptographic Service
SHOULD return a invalid_handshake error. 

The first register_session_ticket MAY request the session_resumption_master.
Next register_new_session MUST not request that secret.If these
conditions are not met, a invalid_key_request error is returned. 

The ticket_list MAY have zero NewSessionTickets for the first
register_new_Session_ticket. Next LURK exchanges MUST have at least one
NewSessionTickets.   

~~~
struct {
    uint32 crypto_service_session_id
    uint32 crypto_service_cookie
    Handshake handshake_context<0..2^32>;     //RFC8446 section 4.
    NewSessionTicket ticket_list<0..2^16-1>; //RFC8446 section 4.6.1.
    uint16 key_request;
} RegisterSessionTicketRequest;

struct {
    uint32 lurk_client_session_id
    uint32 lurk_client_cookie
} RegisterSessionTicketResponse;

~~~
crypto_service_session_id, crypto_service_cookie,
lurk_client_session_id, and lurk_client_cookie are defined in section
{{sec:handshake_and_app_secret}}. handshake_contex is defined in section
{{sec:handshake_context}}. NewSessionTicket is defined in {{!RFC8466}}
section 4.6.1. key_request is defined in {{sec:key_request}}. 



## post_handshake 

The post_handshake LURK exchange is performed in order to the client to
authenticate after the TLS handshake has complete. The TLS client MUST
NOT proceed to this exchange if post handshake support has not been
announced in the ClientHello with the post_handshake_auth extension.
When such extension is not found the Cryptographic Service MUST return a
invalid_handshake error.   
~~~
struct {
    uint32 crypto_service_session_id
    uint32 crypto_service_cookie
    Handshake handshake_context<0..2^32>;     //RFC8446 section 4.
    int16 app_n;
} PostHandshakeRequest;

struct {
    uint32 lurk_client_session_id
    uint32 lurk_client_cookie
} PostHandshakeResponse;
~~~

handshake_context is defined in section {{sec:handshake}}

app_n:
describes the number of iteration of the session keys. 






## secret {#secret}


~~~
enum {
    binder_key (0),
    client_early_traffic_secret(1),
    early_exporter_master_secret(2),
    client_handshake_traffic_secret(3),
    server_handshake_traffic_secret(4),
    client_application_traffic_secret_0(5),
    server_application_traffic_secret_0(6),
    exporter_master_secret(7)
    (255)
} SecretType;

struct {
    SecretType secret_type;
    opaque secret_data<0..2^8-1>;
} Secret;
~~~

#########
ctx_id:
initializes the key schedule context of the Cryptographic Service and
set the PSK when set to type init_id. For future exchange the ctx_id
enforces the origin and appropriate sequence of requests. (see section
{{sec:ctx_id}})

## handshake_context



The secrets generated by the Cryptographic Service are also limited by
the capabilities of the TLS client or TLS server. In some cases, such
capabilities are restricted by configuration and in other cases, these
are based on the capabilities announced by the TLS client (ClientHello)
as well as chosen by the TLS server (ServerHello). 

Parameters that are expected to restrict the generated secrets:

early_exporter:
is set when the application uses exporters in 0-RTT. This
application specific. When set 0rtt MUST be set and
early_exporter_master_secret is provided to the application. By default,
early_exp is unset. 

application:
is set when the application carries the application data over the TLS
session. TLS is not only used as an handshake protocol. By default
application is set.

exporter:
is set when the application is uses exporter. This is application
specific. When set, exporter_master_secret is returned to the
application. By default, exporter is unset.

Parameters that are announced by the TLS client:






is defined by a state diagram defined for the
LURK client and the Cryptographic Service respectively located on the
TLS client and the TLS server. Each entity maintains the various key
schedule context (ks_ctx) which among other contains the necessary
information about the next request to be performed (resp. accepted). To
ensure the appropriated ordering of the request from the legitimate LURK
client, a ctx_id of type opaque is deterministacaly generated by both
parts but is unpredictable from a passive observer. This context is
removed when the entity is in a finished state.  


As the interaction between the LURK client and the Cryptographic Service
follows the TLS handshake, the different state diagrams indicates the
TLS handshake message that triggers the LURK exchange or the TLS
handshake message that can be sent after the LURK exchange. The
parameters that are belongs to the configuration of the TLS client or
TLS server is mentioned in capital letters. The exchange is indicated
by the type of the request. 


The Cryptographic Service contains three databases:

CTX_ID_DB:
database that contains the valid ctx_id of type opaque.

PSK_DB:
contains the list of PSKs, with associated parameters such as
Hash function. This database includes the session resumption tickets.

Key_DB:
contains the asymetric signing keys with supported signing
algorithms.

# LURK state diagrams on TLS on TLS client {#sec:state_diagram_client}

The state diagram sums up the LURK exchanges. The notations used are defined below:

LURK exchange indicates a LURK exchange is stated by the LURK client or
is received by the Cryptographic Service ----> (resp. <----) indicates a
TLS message is received (resp. received). These indication are
informative to illustrates the TLS state machine. 

CAPITAL LETTER indicates potential configuration parameters or policy
applied by the LURK client or the Cryptographic Service. The following
have been considered:

* PSK, PSK-ECDHE, ECDHE that designates the authentication method. This
choice is made by the LURK client. The choice is expressed by a specific
LURK exchange as well as from the TLS handshake context.

* SESSION_RESUMPTION indicates the session resumption has been enabled
on the LURK client or the Cryptographic Service. As a consequence the
TLS client is considered performing session resumption and the TLS
server MUST make session resumption possible. 

* POST_HANDSHAKE_AUTH indicates that post handshake authentication
proposed by the TLS client in a post_handshake_auth extension is not
ignored by the LURK client or on the Cryptographic Service. 

Note that SESSION_RESUMPTION, POST_HANDSAHKE_AUTH are mostly informative
and the current specification does not mandate to have such
configuration parameters. By default, these SHOULD be enabled. 

Other potential configuration could be proposed for configuring LURK
client or Cryptographic Service policies. These have not been
represented in the state diagram and the specification does not mandate
to have these parameters implemented.  

* CLIENT_EARLY_TRAFFIC indicates that client early traffic MAY be sent
by the TLS client and the notification by the TLS client in the
ClientHello via the early_data extension MUST be considered. 

* EARLY_EXPORTER_MASTER_SECRET indicates whether or not
early_exporter_master_secret MUST be requested by the LURK client and
responded by the Cryptographic Service. 

* MASTER_EXPORTER  indicates whether or not
exporter_master_secret MUST be requested by the LURK client and
responded by the Cryptographic Service. 

* SESSION_RESUMPTION_DELEGATION indicates whether or not
session_resumption_master is requested by the LURK client and responded
by the Cryptographic Service. 

* MAX_SESSION_TICKET_NBR indicates the maximum number of tickers that
can be requested or provided by the LURK client and provided by the
Cryptographic Service. It is strongly RECOMMENDED to have such
limitations being configurable.  


The analysis of the TLS handshake context enables to set some variables
that can be used by the LURK client to determine which LURK exchange to
proceed as well as by the Cryptographic Service to determine which
secret MAY be responded. The following variables used are:

psk_proposed:
The TLS Client is proposing PSK authentication by including a
pre_shared_key and a psk_key_exchange_mode extensions in the
ClientHello. 

dhe_proposed:
The received or to be formed ClientHello contains a key_share
extensions.

psk_accepted: 
The chosen authentication method is pSK or PSK-ECDHE which is indicated
via the pre_shared_key extension in the ServerHello.  

0rtt_proposed:
Indicates the TLS client supports early data which is indicated by the
early_data extension in the  ClientHello.

post_handshake_proposed:
indicates the TLS client supports post handshake authentication which is
indicated by the presence of a post_handshake_auth extension in the
ClientHello.

finished:
indicates that the LURK client or the Cryptographic Service has
determined the session shoudl be closed an ks_ctx are deleted.

## LURK client

~~~
              TLS Client Policy for authentication
              PSK, PSK-ECDHE                    ECDHE
                       |                           |
                       |                           |
                       v                           |
  psk  ---> +--------------------+                 |
            | binder_key         |                 |
            +--------------------+                 |
EARLY_EXPORTER, 0-RTT  |                           |
                v      |                           |
            /------------------------\ NO          |
            \------------------------/----+        |
                   YES v                  |        |
            +--------------------+        |        |
            |   early_secret     |        |        |
            +--------------------+        |        |
ClientHello            |                  |        |
<----                  +<-----------------+--------+
ServerHello        YES v
      ----> +-------------------------------------------+
            | init_handshake_secret or handshake_secret |
            +-------------------------------------------+
                       |
            /--------------------\ NO
            | CertificateRequest |------+
            \--------------------/      |
                   YES v                v
            +--------------------+-----------------+
            | certificate_verify |    app_secret   |
            +--------------------+-----------------+
client Finished     |                     |
<----               +------+--------------+
POST_HANDSHAKE_AUTH        |
                v          v
             /-------------------------\ NO
             | post_hand_auth_proposed |------+
             \-------------------------/      |
                       YES v                  |
           +-----------------------------+    |
           | register_session_tickets    |    |
           | (empty NewSessionTickets)   |    |
           +-----------------------------+    |
                           |                  |
                           +<-----------------+
                           |
                           +<--------------------------------------------------------------+
                           |                                                               |
                           +---------------------------------------------------+           |
      SESSION_RESUMPTION   |                       POST_HANDSHAKE_AUTH v       v           |
client Finished     v      v          CertificateRequest  /-------------------------\ NO   |
NewSessionTickets /---------------------\ NO        ----> | post_hand_auth_proposed |----+ |
            ----> \---------------------/---------+       \-------------------------/    | |
                            YES v                 |              YES v                   | |
                  +-----------------------------+ |       +-------------------------+    | |
                  |  register_session_ticket    | |       |     post_handshake      |    | |
                  +-----------------------------+ |       +-------------------------+    | |
                                v                 v                   v                  | |
                                +-----------------+----------+--------+------------------+ |
                                                             v                             |
                                                    /--------------------\ NO              |
                                                    |      finished      |-----------------+
                                                    \--------------------/
                                                          YES v
                                                 +-------------------------+
                                                 | LURK exchanges Finished |
                                                 +-------------------------+
~~~

## Cryptographic Service

~~~
       TLS13Request
             |
(PSK,        +<------------------------------------------------------------------------------------+
PSK-ECDHE)   |                              (ECDHE)                                                |
/---------------------------\    /---------------------------\                                     |
| type is binder_key        | NO | type is init_handshake    | NO                                  |
|                           |--->| and !psk_proposed         |---------------+                     |
\---------------------------/    \---------------------------/    \-         |                     |
             |                              |                            YES v                     |
             |                              |                     /--------------------------\NO   |
             |                              |                     | type is (certificate_    |     |
             |                              |                     | verify or post_handshake)|---+ |
             |                              |                     \--------------------------/   | |
             |                              |                            YES v                   | |
             |                              |                     /--------------------------\NO | |
             |                              |                     | type is register_session_|   | |
             |                              |                     | ticket and               |   v |
             |                              |                     | session_resumption       |---+ |
             |                              |                     \--------------------------/   | |
        YES  v                         YES  v                            YES v                   | |
/---------------------------\NO  /---------------------------\NO  /--------------------------\NO | |
| psk_proposed              |--+ | dhe_proposed              |--+ | ctx_id in CTX_ID_DB      |---+ |
| psk_key in PSK_DB         |  | \---------------------------/  v \--------------------------/   v |
\---------------------------/  +------------|-------------------+------------|-------------------+ |
             |                          YES |      +-------+    |        YES v                     |
             +------------------------------+      | Error |<---+ /--------------------------\     |
         YES v                                     +-------+      | ks_ctx is pending        |---+ |
+---------------------------+                                     \--------------------------/   | |
| Init key schedule context |                                            YES v                   | |
+---------------------------+                                     +----------------------------+ | |
             v                                                    |  ks_ctx.state=selected     | | |
+---------------------------+                                     |(del related pending ks_ctx)| | |
| state=pending             |                                     +----------------------------+ | |
| set psk_proposed,         |                                                |                   | |
| set dhe_proposed,         |                                                +<------------------+ |
| 0rtt_proposed             |                                                |                     |
| post_handshake_proposed   |                                                |                     |
+---------------------------+                                                |                     |
             |                                                               |                     |
             +<--------------------------------------------------------------+                     |
             v                                                                                     |
/---------------------------\                                                                      |
| TLS13request.type in      |                                                                      |
| ks_ctx.next_request       |                                                                      |
\---------------------------/                                                                      |
             v                                                                                     |
+---------------------------+                                                                      |
| process TLS13Request      |                                                                      |
| update CTX_ID_DB, key     |                                                                      |
| schedule context, PSK_DB  |                                                                      |
+---------------------------+                                                                      |
             v                                                                                     |
/---------------------------\ NO                                                                   |
| finished                  |----------------------------------------------------------------------+
\---------------------------/
         YES v
+---------------------------+
| delete ks_ctx             |
+---------------------------+

~~~

# LURK state diagrams on TLS on TLS server {#sec:state_diagram_server}

## LURK client


~~~
                 TLS Server Policy for authentication
received      PSK, PSK-ECDHE,                   ECDHE
ClientHello            |                          |
      ---->            v                          v
  psk  ---->+----------------------+    +----------------------+
            | Init ks_ctx          |    | Init ks_ctx          |
            +----------------------+    +----------------------+
                       v                           |
            +---------------------+                |
            | early_secret        |                |
            +---------------------+                |
                       |                           |
to be formed       YES v                           v
ServerHello +--------------------------+   +-------------------------+
      ----> | handshake_and_app_secret |   | init_certificate_verify |
            +--------------------------+   +-------------------------+
                       |                           |
   SESSION RESUMPTION  +---------------------------+
               |       |
ServerHello    v       v
      <---- /--------------------\ NO
            | session_resumption |------+
            \--------------------/      |
                 YES |                  |
                     +----------------+ |
client               v                | |
Finished    +----------------------+  | |
or    ----> | new_session_tickets  |  | |
other       +----------------------+  | |
trigger              v                | |
            /--------------------\ NO | |
            |      finished      |----+ |
            \--------------------/      |
                 YES v                  v
            +----------------------------------+
            |      LURK exchanges Finished     |
            +----------------------------------+
~~~



##  Cryptographic Service


~~~
        TLS13Request
             |
(PSK,        +<------------------------------------------------------------------------------------+
PSK-ECDHE)   |                              ECDHE                                                  |
/---------------------------\    /---------------------------\    /--------------------------\     |
| type is early_secret and  | NO | type is init_cert_verify_ | NO | type is (handshake or    |     |
|                           |--->|                           |--->| handshake_and_app_secret |     |
| and psk_proposed          |    |                           |    | or new_session_ticket)   |     |
|                           |    |                           |    | and ctx_type is opaque   |     |
\---------------------------/    \---------------------------/    \--------------------------/     |
        YES  v                         YES  |                            YES v                     |
/---------------------------\NO +-----+     |                     /--------------------------\NO   |
| psk in PSK_DB             |-->|Error|     |                     | ctx_id in CTX_ID_DB      |---+ |
\---------------------------/   +-----+     |                     \--------------------------/   v |
             |                              |                            YES v                     |
             +<-----------------------------+                     /--------------------------\     |
         YES v                                                    | ks_ctx is pending        |---+ |
+---------------------------+                                     \--------------------------/   | |
| Init key schedule context |                                            YES v                   | |
+---------------------------+                                     +----------------------------+ | |
             v                                                    |  ks_ctx.state=selected     | | |
+---------------------------+                                     |(del related pending ks_ctx)| | |
| state=pending             |                                     +----------------------------+ | |
| set psk_proposed,         |                                                |                   | |
| set dhe_proposed,         |                                                +<------------------+ |
| 0rtt_proposed             |                                                |                     |
| post_handshake_proposed   |                                                |                     |
+---------------------------+                                                |                     |
             |                                                               |                     |
             +<--------------------------------------------------------------+                     |
             v                                                                                     |
/---------------------------\ NO +-------+                                                         |
| TLS13request.type in      |--->| ERROR |                                                         |
| ks_ctx.next_request       |    +-------+                                                         |
\---------------------------/                                                                      |
         YES v                                                                                     |
+---------------------------+                                                                      |
| process TLS13Request      |                                                                      |
+---------------------------+                                                                      |
             v                                                                                     |
/---------------------------\ NO +------------------+                                              |
| finished                  |--->| update CTX_ID_DB |----------------------------------------------+
\---------------------------/    | update ks_ctx    |
         YES v                   +------------------+
+---------------------------+
| update CTX_ID_DB, PSK_DB  |
| delete ks_tcx             |
+---------------------------+
~~~


# Message Description

The different exchanges between the LURK client and the Cryptographic
Service can fall into three categories:
* Retrieving secrets with eventually signing operations. Such exchanges
occurs during the TLS handshake 
* Session ticket management: request for NewSessionTickets or to
register NewSessionTickets
* Post Handshake

Interactions between the LURK client and the Cryptographic Service is
represented by a sequence of request. The purpose of the ctx_id is to
initiate the sequence with a type of init_id or to assert the request is
legitimate with ctx_id of type opaque. 



The generation of secrets requires inputs such as PSK, ECDHE share
secret as well as Handshake Context. PSK is provided within the ctx_id
of type init_id. Other parameters are provided as available or
necessary. Handshake Context is provided via the handshake_context, and
ECDHE secret are provided via the ephemeral_secret combined with the
public value available in the handshake_context.

The signing operation is also associated to a Handshake Context
(handshake_context, certificate) as well as the private key used to perform the
signing operation (key_id). In addition, signing operations may also be
combined with secret generation (init_certificate_verify).








struct {
    HandshakeSecretsRequest handshake_request;
} CertificateVerifyRequest;


struct {
    SecretsResponse secret_response;
    opaque signature<0..2^16-1>; //RFC8446 section 4.4.3.
    Finished finished;            // RFC8446 section 4.4.4.
} CertificateVerifyResponse;


struct {
    ContextID ctx_id;
    uint8 ticket_nbr;
    Handshake handshake_context<0..2^32> //RFC8446 section 4.
} NewSessionTicketRequest;

struct {
    NewSessionTicket ticket_list<0..2^16-1>; //RFC8446 section 4.6.1.
} NewSessionTicketResponse;

struct {
    ContextID ctx_id;
    Handshake handshake_context<0..2^32>;     //RFC8446 section 4.
    NewSessionTicket ticket_list<0..2^16-1>; //RFC8446 section 4.6.1.
} RegisterSessionTicketRequest;

struct {} RegisterSessionTicketResponse;

struct {
    ContextID ctx_id;
    Handshake handshake_context<0..2^32>;     //RFC8446 section 4.
    int16 app_n;
} PostHandshakeRequest;

~~~

# TLS server

## early_secret

## 


# TLS client

## early_secret



# handshake_server_key

This exchange is only expected to be performed by a TLS Client. The
server_handshake_key is necessary for the TLS Client to decrypt the
handshake message/extensions encrypted by the TLS Server. 

Interaction with a Cryptographic Service is required when the PSK is
protected by the Cryptographic Service. 

TLS 1.3 defines various key exchange modes (ke_mode): (EC)DHE (dhe_ke) as well as
modes that involves a PSK, PSK-only (psk_ke) and PSK in combination of
(EC)DHE (psk_dhe_ke). psk_dhe and psk_ke are defined in {{!RFC8446}}
section 4.2.9 in the PskKeyExchangeMode structure. dhe_ke corresponds to
the absence of that structure. 


## Request Payload {#hsk-req}
~~~

enum { sha256 (0), (255) } TranscriptHash; 

enum { psk_raw (0), psk_ticket (1), (255) } PSKType;

enum { dhe_ke(0), psk_ke(1), psk_dhe_ke(2) (255)} KeyExchangeMode;

struct {
    PSKType psk_type;
    select( psk_type ){
        case raw_psk :
            opaque raw_psk<0..2^16-1>;
        case identity_psk : 
            OfferedPsks offered_psk  // {{!RFC8446}} section 4.2.11
} PSK

struct {
    select ( ke_mode ){ 
        case psk_ke :
            PSK psk
        case psk_dhe_ke :
            PSK psk
            NamedGroup dh_group; // {{!RFC8446}} section 4.2.7
            opaque dhe_secret<1..2^16-1>;
        case dhe_ke:
            NamedGroup dh_group; // {{!RFC8446}} section 4.2.7
            opaque dhe_secret<1..2^16-1>;
    }
} KeyScheduleInputSecrets 


enum { 
    sha256 (0) (255)
} PFSAlgorithm

struct {
    PFSAlgorithm freshness_funct;  // {{!I-D.mglt-lurk-tls12}} section 4.1
    TranscriptHash h;
    KeyExchangeMode ke_mode // {{!RFC8446}} section 4.2.9
    opaque handshake_context<0..2^32-1>
    KeyScheduleInputSecrets secrets
} HandshakeServerKeyRequest
~~~

psk_type
: indicates how the PSK is provisioned to initiate the key schedule as
described in {{!RFC8446}} section 7.1. The type psk_raw
indicates the PSK is explicitly provided. The type psk_ticket indicates
the PSK is generated from the ticket as described in
{{!RFC8446}} section 4.6.1.

freshness_funct
: the one-way hash function (OWHF) used by LURK to implement
Perfect Forward Secrecy.

h
: the hash function used by the Transcript-Hash {{!RFC8446}}
section 4.4.1.

offered_psk
: reuses the  OfferedPsks described in {{!RFC8446}} section
4.2.11. The PSK structure only allow a single PSK, thus OfferedPsks MUST
represent a single PSK.
  
ke_mode 
: defines pre shared key exchange defined in {{!RFC8446}}
section 4.2.9. It indicates whether the key exchange considers a (EC)DHE key
establishment or not in addition to the PSK. 

dh_group 
: reuses the structure NamedGroup of {{!RFC8446}} section
4.2.7 to indicate the curve or the group used in (EC)DHE key
establishment. 

handshake_context 
: the necessary handshake context to generate the key as described in
{{!RFC8446}} section 7.1. The handshake_context MUST be
ClientHello...ServerHello.

secrets
: the necessary secret inputs (PSK, (EC)DHE) secret necessary for the
key schedule of {{!RFC8446}} section 7.1.


## Response Payload

~~~
struct {
    opaque server_handshake_key<0..2^32-1>
} HandshakeServerKeyResponse
~~~

server_handshake_key
: the server_handshake_key

## LURK Client Behavior {#hsk-clt}


The TLS Client establishing a TLS session with a TLS Server receives
from the TLS Server a ServerHello message with additional encrypted
messages such as the EncryptedExtensions, the Finished as well as the
optional Certificate, CertificateVerify and Application Data message. The
TLS Client needs to retrieve the server_handshake_key in order to
decrypt these messages.  

With ServerHello as the input message, the LURK Client initiates the
exchange as described below:

Perfect Forward Secrecy Setting:

* Perfect Forward Secrecy is performed as described in
{{!I-D.mglt-lurk-tls12}} section 4.1.1 over the client_random. There is
no gmt_unix_time as such ServerHello.random is generated as follows:
~~~
ClientHello.random = freshness_funct( client_random + "tls13_c freshness_funct" );
~~~

Transcript Hash Setting:

* the value for transcript hash is provided by the configuration.

PSK Key Exchange Mode Setting:

* if  the input message does not contains any key_share extension, the
LURK Client sets ke_mode to psk_ke. 
* if  a key_share extension is present the LURK Client sets ke_mode to
psk_dhe_ke. 

Key Schedule Input Secret Setting:

* if the input message  has no pre_shared_key extension, the LURK Client
sets psk_type to psk_raw with a psk of length 0. 
* if the input message has a pre_shared_key extension, the LURK Client
provides the PSK that is not a PSK of zero length, as follows:
..* the PSK is provided explicitly by using the psk_type set to psk_raw
with the explicit value of the PSK. This alternative is NOT RECOMMENDED,
as it means the PSK is not known by the Cryptographic Service and is
known outside this service. It may happen when the TLS Client is
configured with a PSK while the Cryptographic Service is not provisioned with
that PSK. The case where the PSK is provided for a session resumption is
outside the scope of this document as the session_resumption_secret is
never shared outside the Cryptographic Service.
..* the PSK is provided via NewSessionTicket. Upon receiving a
selected_identity in the pre_shared_key extension, the LURK Client
selects the corresponding local_ticket previously provided by the LURK
Server during the previous handshake. local_ticket are internal
structure used by LURK detailled in {{local_ticket}}
 

## LURK Server Behavior {#hsk-srv}

Upon receiving a handshake_server_key request, the LURK server proceeds
as follows:

Perfect Forward Secrecy Check:

* if freshness_funct is not supported, an invalid_freshness_funct erroro is returned. 
* ClientHello.random is generated as described in {{hsk-clt}} and
the value is provided in handshake_context.

Transcript-Hash Check: 

* if h is not a supported transcript-hash
function and invalid_transcript_hash error is returned.

Handshake Check:

* if handshake does not contains a ClientHello...ServerHello an
invalid_handshake error is returned.


PSKExchangeMode Check: 

* if ke_mode is not supported an invalid_ke_mode error is returned.

KeyScheduleInputSecret Check check the validity of the secrets as well
as the coherence wit the pre shared key exchange. These checking
operations are subdivided into (EC)DHE Check and PSK Check operations: 

(EC)DHE Check:

* if ke_mode is set to psk_dhe_ke and secret does not contain a (EC)DHE
secret an invalid_secret error is returned.  
* if the (EC)DHE secret does not match the expected length or the curve
is not supported an invalid_ecdhe_secret error is returned.

PSK Check:

* if the psk type is not supported a invalid_psk_type is returned. 
* if psk_type is psk_raw and the format of the psk is unexpected an
invalid_psk_format error is returned.
* if the psk_type is psk_ticket:

..* if the number of psk or associated binder is more than 1, an
invalid_ticket_format error is returned
..* there is no corresponding identity, an invalid_psk_ticket error is returned. 
* if the psk_type is identity_psk binder_key is generated as described
in {{!RFC8446}} section 7.1.
..* if the binder associated to the psk does not match the one provided
in the offered_psk and invalid_binder error is returned. The binder is
computed as described in {{!RFC8446}} section 4.2.11.2. with
the binder_key generated as described in {{!RFC8446}} section
7.1.

Key Generation:

* server_handshake_key is generated as described in
{{!RFC8446}} section 7.1 and returned to the LURK Client. 


# auth

This exchange provides interactions with a Cryptographic Service both on
the TLS Client side as well as the TLS Server side. 

The pupose of teh exchange is to obtain a CertificateVerify, the
Finished message as well as the necessary keys to encrypt/decrypt the
handshake messages as well as the application data. 

Note the Finished message does not involve any private key nor PSK. As a
result, it does not need to be performed within the Cryptographic
service in order to protect the security credentials. On the other hand,
the Cryptographic Service is responsible to perform the key scheduling
and deliver the 
Cryptographic Service, however, the Cryptographic Service computes the
CertificateVerify message  

## Request Payload {#auth-req}


~~~
enum { server (0), client (1), post-handshake (2) } HandshakeMode; 

struct {
    PFSAlgorithm freshness_funct;  // {{!I-D.mglt-lurk-tls12}} section 4.1
    TranscriptHash h;  // c, f
    KeyExchangeMode ke_mode // {{!RFC8446}} section 4.2.9
    select( ke_mode ){
        case : psk_dhe_ke, dhe_ke
        KeyPairID key_id // {?draft-mglt-lurk-tls12} section 3.
----- KeyID??            Certificate certificate        // {{!RFC8446}} section 4.4.2
            SignatureScheme sig_algo     // {{!RFC8446}} section 4.2.3.
    }
    HandshakeMode handshake_mode        // c, f
    opaque handshake_context<0..2^32-1> // c, f
    KeyScheduleInputSecrets secrets // f
    uint8 key_request
    uint8 ticket_number
} AuthRequest

c: structure used for the CertificateVerify message
f: structure used for the Finished message
~~~

freshness_funct, h, ke_mode, handshake_context and secrets are define in {{hsk-req}}

---certificate 
---: end point certificate defined in {{!RFC8446}} section
---4.4.2.

key_id: 
designation of the private key as defined in {{?draft-mglt-lurk-tls12}}
section 3.

algorithm
: signature algorithm used defined in {{!RFC8446}} section 4.2.3.

handshake_mode
: defines the specific Handshake Context and Base Key necessary to
compute authentication messages as defined in {{!RFC8446}}
section 4.4. The handshake_mode set to server indicates the LURK
exchange is performed by the TLS Server while the handshake_mode set to
client or post-handshake indicates the LURK exchange is performed by the
TLS Client. 

handshake_context 
: Handshake Context has defined in {{!RFC8446}} section 4.4.

key_request
: indicates optional requested keys. The bit is set to 1 to indicate the
key is being requested by the LURK Client.
..* bit 0 : binder_key
..* bit 1 : client_early_traffic_secret
..* bit 2 : early_exporter_master_secret 
..* bit 3 : client_handshake_traffic_secret
..* bit 4 : server_handshake_traffic_secret
..* bit 5 : client_application_traffic_secret_0
..* bit 6 : server_application_traffic_secret_0
..* bit 7 : exporter_master_secret

ticket_number 
: indicates the expected number of session resumption tickets. When
requested by the TLS Client the ticket_number is expected to be 0 or 1.
When requested by the TLS Server the number can be larger. 

## Response Payload

~~~
struct{
    opaque key<0..2^16-1>
} Key 

struct {
    uint8 key_index
    opaque key_list<0..2^32-1>
} Keys

struct {
    Keys keys
    CertificateVerify certificate_verify
    Finished finished
    NewSessionTicket ticket_list<0..2^32-1> 
} AuthResponse
~~~

key_index
: follows the same syntax as key_request in {{auth-req}}.

key_list 
:the list of keys indicated by key_index.

ticket_list 
: list of NewTicketSessions


## LURK Client Behavior (TLS Server) {#auth-clt-srv_tls}

On a TLS Server, the LURK Server initiates the LURK exchange after
receiving the ClientHello from the TLS Client. The purpose of this
exchange is to retrieve the CertificateVerify, Finished, and the
necessary keys to:

* encrypt the EncryptedExtensions, Finished and optional
CertificateRequest Certificate and CertificateVerify message:
server_handshake_traffic_secret
* encrypt the optional Application Data message:
server__application_traffic_secret_N
* decrypt the future Finished or optional Certificate and
CertificateVerify message sent by the TLS Client:
client_handshake_traffic_secret. 
* decrypt the future Application Data message with the 
client__application_traffic_secret_N

Perfect Forward Secrecy Setting:

* Perfect Forward Secrecy is performed as described in
{{!I-D.mglt-lurk-tls12}} section 4.1.1 over the server_random. There is
no gmt_unix_time as such ServerHello.random is generated as follows:
~~~
ServerHello.random = freshness_funct( server_random + "tls13_s freshness_funct" );
~~~


The LURK Client proceeds to the Transcript Hash Setting
PSK Key Exchange Mode Setting and the Key Schedule Input Secret Setting
as described in {{hsk-clt}}. 

Handshake Mode Setting:

* If the LURK Client sets the handshake_mode to "server". 

Handshake Setting:
The handshake is set as described in {{!RFC8446}} section
4.4.

Key Request Setting:

* key_request MUST have the Bit 0 and Bit 1 set to retrieve the
[sender]_handshake_traffic_secret. 
* key_request MUST have the Bit 2 and Bit 3 set to retrieve the
[sender]_application_traffic_secret_N
* Key_request MAY have Bit 4 set if there is a need to use the extractor. 

Upon receiving the AuthResponse, the TLS Server encrypts the messages
and pursue the TLS handshake as defined in {{!RFC8446}}. 


## LURK Client Behavior (TLS Client)

On a TLS Client the LURK Client initiates an AuthRequest in order to
compute the Finished and optional CertificateVerify as well as to
retrieve the necessary keys to:

* encrypt the Finished and optional Certificate and CertificateVerify
message: client_handshake_traffic_secret
* encrypt the optional Application Data message:
server__application_traffic_secret_N
* decrypt the future Application Data message with the
server__application_traffic_secret_N

The TLS Client has decrypted the encrypted handshake messages sent by
the TLS Server by retrieving the server_handshake_traffic_secret with an
HandshakeServerKeyRequest.


The LURK Client proceeds to Perfect Forward Secrecy Setting, Transcript
Hash Setting, Key Schedule Input Secret Setting as described in
{{hsk-clt}}. 

If the TLS Client has received a CertificateRequest from the TLS Server,
the LURK Client:

* sets the ke_mode to psk_dhe_ke. Note that the value is not correlated
to the value agreed psk_key_exchange_modes between the TLS Client and
the TLS Server. Instead it indicates the necessity to generate a
CertificateVerify. 
* provides the Certificate associated to the private key of the TLS


Handshake Mode Setting:

* If the LURK Client is initiating a LURK exchange on behalf of a TLS
Client it sets the handshake_mode to:
..* "client" when the LURK exchange occurs during the TLS handshake.
..* "post-authentication" when the LURK exchange occurs outside the TLS
handshake. 

Handshake Setting:

* set handshake_context as defined in {{!RFC8446}} section 4.4.

Key Request Setting:

* key_request SHOULD have the Bit 0 unset, as
client_handshake_traffic_secret is already known by the TLS Client 
* key_request MUST have the Bit 1 set to retrieve the
server_handshake_traffic_secret. 
* key_request MUST have the Bit 2 and Bit 3 set to retrieve the
[sender]_application_traffic_secret_N
* Key_request MAY have Bit 4 set if there is a need to use the extractor. 

Ticket Number Setting:

* If the TLS Client want to performed further session resumption,
ticket_number is set to 1 and 0 otherwise.


Upon receiving the AuthResponse, the LURK Client has the necessary
information to proceed the TLS handshake.  The ticket_list is a list of
local_ticket. The list MUST have a maximum of one local_ticket. The LURK
Client is expected to manage the local_tickets as described in
{{local_ticket}}


### Local Ticket {#local_ticket}

local_ticket re-uses the NewSessionTicket structure in two different
ways depending if the LURK exchange is initiated by a TLS Client or by a
TLS Server. 

* ticket provided to the TLS Server (by the LURK Server)  are
new_session_ticket, expected to be forwarded to the TLS Client.
* tickets provided to the TLS Client ( by the LURK Server) are
local_ticket. These local_tickets are only expected to be used between
the LURK Client and the LURK Server of the TLS Client.    

During the initial handshake, the TLS Client has received a local_ticket
from the LURK Server and a new_session_ticket from the TLS Server. The
TLS Client updates the  local_ticket as follows:  the ticket_nonce and
extensions fields of the new_session_ticket are copied to the
local_ticket. 

When the TLS Server provides more than one new_session_ticket
tickets, these tickets are expected to have different nonce. On the
other hand a single local_ticket will be provided by the LURK Server.
The TLS Client generates an associated local_ticket for each
new_session_ticket. All of them are generated from the local_ticket
provided by the LURK Server. 

Though the new_Session_ticket and the local_ticket have different
meanings, a TLS Client will not be able to perform session resumption
without the corresponding local_ticket. More specifically, the TLS
Client MUST:

* remove local_tickets and new_session_tickets that have expired
* remove local_tickets that have no associated new_session_tickets
* remove new_session_tickets that have no associated local_tickets
In all these cases, a new handshake will be renegotiated. Note that this
gives the Cryptographic Service the ability to define the maximum time a
new_session_ticket can be used. 


## LURK Server Behavior

Upon receiving a handshake_server_key request, the LURK server proceeds
as follows:

Perfect Forward Secrecy Check is performed as {{hsk-clt}} using the freshness_funct,
and client_random (resp. server_random) as described in {{hsk-clt}}
(resp. {{auth-clt-srv_tls}}).

Transcript-Hash Check, PSKExchangeMode Check,
KeyScheduleInputSecrets Check  are performed as described in {{hsk-srv}}

HandshakeMode Check:

* if the mode is not supported a invalid_handshake_mode error is
returned. This typically prevents a TLS Client to perform computation
expected to happen on the TLS Server, or to distinguish and authorize
client authentication performed during the handshake or post handshake.   

Handshake Check:

* if the hanshake_context does not match the expected handshake context
as defined in {{!RFC8446}} section 4.4. an
invalid_handshake error is returned. 

CertificateVerify Check:

* if ke_mode is set to psk_dhe_ke and the certificate is not supported
 an invalid_certificate error is returned
* if ke_mode is set to psk_dhe_ke and the algorithm is not supported
an invalid_signature_scheme error is returned


Keys are generated as described in {{!RFC8446}}
section 7.1. This includes the Base Key use to generate the Finished
messages as well as the resumption_master_secret.

key_request is indicative and is used by the LURK Client to indicate the
keys that are not necessarily needed in order to save bandwidth. The
LURK Server SHOULD NOT responds with keys whose key_request bit is
unset. 

The CertificateVerify message is generated as described in
{{!RFC8446}} section 4.4.3. 

The Finished message is generated as described in
{{!RFC8446}} section 4.4.4. 

ticket_number indicates the number of NewSessionTicket. ticket_session
have different meaning when used by the TLS Client or the TLS Server.
When the LURK exchange is initiated by the LURK Client, the
ticket_sessions are local_ticket and are only expected to be used
between the LURK Client and the LURK Server. Such local_ticket avoids a
direct communication of the resumption_master_secret.  local_ticket
follows the definition of new_session_tickets described in
{{!RFC8446}} section 4.6.1. The LURK Server MUST have a zero
length ticket_nonce and zero length extensions 

When the LURK exchange is initiated by the TLS Server the tickets are
new_session_tickets as described in {{!RFC8446}} section
4.6.1. As a result:

* if handshake_mode is set to server, the LURK Server SHOULD respond
with a list of new_session_tickets that is not greater than the number
indicated by ticket_number. The number of ticket MAY be defined by the
LURK Server policies. 
* if handshake_mode is set to client or post-handshake the LURK Server
SHOULD respond with a list of local_ticket that is not greater than the
number indicated by ticket_number. The list MUST NOT exceed one
local_ticket.  


# Security Considerations

Security credentials as per say are the private key used to sign the
CertificateVerify when ECDHE authentication is performed as well as the
PSK when PSK or PSK-ECDHE authentication is used. 

The protection of these credentials means that someone gaining access to
the Cryptographic Service MUST NOT be able to use that access from
anything else than the authentication of an TLS being established. In
other way, it MUST NOT leverage this for:
* any operations outside the scope of TLS session establishment.
* any operations on past established TLS sessions
* any operations on future TLS sessions
* any operations on establishing TLS sessions by another LURK client.

The Cryptographic Service outputs are limited to secrets as well as
NewSessionTickets. The design of TLS 1.3 make these output of limited
use outside the scope of TLS 1.3. Signature are signing data specific to
TLS 1.3 that makes the signature facility of limited interest outside
the scope of TLS 1.3. NewSessionTicket are only useful in a context of
TLS 1.3 authentication. 

ECDHE and PSK-ECDHE provides perfect forward secrecy which prevents past
session to be decrypted as long as the secret keys that generated teh
ECDHE share secret are deleted after every TLS handshake. PSK
authentication does not provide perfect forward secrecy and
authentication relies on the PSK remaining sercet. The Cryptographic
Service does not reveal the PSK and instead limits its disclosure to
secrets that are generated from the PSK and hard to be reversed. 

Future session may be impacted if an attacker is able to authenticate a
future session based on what it learns from a current session. ECDHE
authentication relies on cryptographic signature and an ongoing TLS
handshake. The robustness of the signature depends on the signature
scheme and the unpredictability of the TLS Handshake. PSK authentication
relies on not revealing the PSK. The Cryptographic Service does not
reveal the PSK. TLS 1.3 has been designed so secrets generated do not
disclose the PSK as a result, secrets provided by the Cryptographic do
not reveal the PSK. NewSessionTicket reveals the identity (ticket) of a PSK.
NewSessionTickets.ticket are expected to be public data. It value is
bound to the knowledge of the PSK. The Cryptographic does not output any
material that could help generate a PSK - the PSK itself or the
resumption_master_secret. In addition, the Cryptographic only generates
NewSessionTickets for the LURK client that initiates the key schedule
with Cryptographic Service with a specific way to generate ctx_id. This
prevents the leak of NewSessionTickets to an attacker gaining access to
a given Cryptographic Service. 

If an the attacker get the NewSessionTicket, as well as access to the
Cryptographic Service of the TLS client it will be possible to proceed
to the establishment of a TLS session based on the PSK. In this case,
the Cryptographic Service cannot make the distinction between the
legitimate TLS client and teh attacker.  This corresponds to the case
where the TLS client is corrupted. 

Note that when access to the Cryptographic Service on the TLS server
side, a similar attack may be performed. However the limitation to a
single re-use of the NewSessionTicket prevents the TLS server to proceed
to the authentication.  

Attacks related to other TLS sessions are hard by design of TLS 1.3
that ensure a close binding between the TLS Handshake and the generated
secrets. In addition communications between the LURK client and the
Cryptographic Service cannot be derived from an observed TLS handshake
(freshness function). This makes attacks on other TLS sessions unlikely. 

# IANA Considerations

#  Acknowledgments


# Appendix

This section is non normative. It illustrates the use of LURK in various
configurations.  

The TLS client may propose multiple ways to authenticate the
server (ECDHE, PSK or PSK-ECDHE). The TLS server may chose one of those,
and this choice is reflected by the LURK client on the TLS server. In
other words, this decision is out of scope of the Cryptographic Service. 

The derivation of the secrets is detailed in {{!RFC8446)) section 7.1.
Secrets are derived using Transcript-Hash and HKDF, PSK and ECDHE
secrets as well as some Handshake Context.   

The Hash function:
When PSK or PSK-ECDHE authentication is selected, the Hash function is a
parameter associated to the PSK. When ECDHE, the hash function is
defined by the cipher suite algorithm negotiated. Such algorithm is
defined in the cipher_suite extension provided in the ServerHello which
is provided by the LURK client in the first request when ECDHE
authentication is selected. 

PSK secret:
When PSK or PSK-ECDHE authentication is selected, the PSK is the PSK
value identified by the identity. When ECDHE authentication is selected,
the PSK takes a default value of string of Hash.length bytes set to
zeros.
 

ECDHE secret:
When PSK or PSK-ECDHE authentication is selected, the ECDHE secret takes
the default value of a string of Hash.length bytes set to zeros. The
Hash is always known as a parameter associated to the selected PSK. When
ECDHE authentication is selected, the ECDHE secret is generated from the
secret key (ephemeral_sercet) provided by the LURK client and the
counter part public key in the key_share extension. When the LURK client
is on the TLS client, the public key is provided in the ServerHello.
When the LURK client is on the TLS Server, the public key is provided in
the ClientHello. When ECDHE secret is needed, ClientHello...ServerHello
is always provided to the Cryptographic Service.    

Handshake Context:
is a subset of Handshake messages that are necessary to generated the
requested secrets. The various Handshake Contexts are summarized below:

~~~
+------------------------------------+--------------------------------+
| Key Schedule secret or key         | Handshake Context              |
+---------------------------------------------------------------------+
| binder_key                          | None                          |
| client_early_traffic_secret         | ClientHello                   |
| early_exporter_master_secret        | ClientHello                   |
| client_handshake_traffic_secret     | ClientHello...ServerHello     |
| server_handshake_traffic_secret     | ClientHello...ServerHello     |
| client_application_traffic_secret_0 | ClientHello...server Finished |
| server_application_traffic_secret_0 | ClientHello...server Finished |
| exporter_master_secret              | ClientHello...server Finished |
| resumption_master_secret            | ClientHello...client Finished |
+---------------------------------------------------------------------+
~~~


The Cryptographic Service has always the Hash function, the PSK and
ECDHE secrets and the only remaining parameter is the Handshake Context.
The remaining sections will only focus on checking the Handshake Context
available to the Cryptographic Service is sufficient to perform the key
schedule.  

When ECDHE authentication is selected both for the TLS server or the TLS
client, a CertificateVerify structure is generated as described in
{{!RFC8446}} section 4.4.3.. CertificateVerify consists in a signature
over a context that includes the output of Transcript-Hash(Handshake
Context, Certificate) as well as a context string. Both Handshake
Context and context string depends on the Mode which is set to server in
this case via the configuration of the LURK server. Similarly to the key
schedule, the Hash function is defined by the PSK or the ServerHello.
The values for the Handshake Context are represented below: 

~~~
+-----------+-------------------------+-----------------------------+
| Mode      | Handshake Context       | Base Key                    |
+-----------+-------------------------+-----------------------------+
| Server    | ClientHello ... later   | server_handshake_traffic_   |
|           | of EncryptedExtensions/ | secret                      |
|           | CertificateRequest      |                             |
|           |                         |                             |
| Client    | ClientHello ... later   | client_handshake_traffic_   |
|           | of server               | secret                      |
|           | Finished/EndOfEarlyData |                             |
|           |                         |                             |
| Post-     | ClientHello ... client  | client_application_traffic_ |
| Handshake | Finished +              | secret_N                    |
|           | CertificateRequest      |                             |
+-----------+-------------------------+-----------------------------+
~~~

When ECDHE authentication is selected, the Cryptographic Service
generates a Finished message, which is a MAC over the value
Transcript-Hash(Handshake Context, Certificate, CertificateVerify) using
a MAC key derived from the Base Key. As a result, the same Base Key and
Handshake Context are required for its computation describe din
{{!RFC8466}} section 4.4.4..



## TLS 1.3 Full Handshake with ECDHE authentication only, no TLS client authentication 


This example illustrates the case of a TLS handshake where the TLS
server is authenticated using ECDHE only, that is not PSK or PSK-ECDHE
authentication is provided and so session resumption is not provided
either. 

### TLS Client: ClientHello (#sec:ecdhe-no-resumption-client-hello}

The TLS client does not provides any PSK and  omits the pre_shared_key as
well as the psk_key_exchange_mode extensions. Note that omiting the
psk_key_exchange_mode extension prevents the TLS client to perform
further session resumption. 

The TLS client does not need any interaction with the Cryptographic
Service to generate and send the ClientHello message to the TLS server. 

~~~
TLS Client                                   TLS Server

    Key  ^ ClientHello
    Exch | + key_share
         v + signature_algorithms ---------> 
~~~

### TLS Server: ServerHello  (#sec:ecdhe-no-resumption-server-hello}


Upon receiving the ClientHello, the TLS server determines the TLS client
requests an ECDHE authentication. The TLS server initiates a LURK
session to provide ECDHE authentication as represented below: 

~~~
TLS Client                                   TLS Server

                                             ServerHello  ^ Key
                                             + key_share  | Exch
                                   {EncryptedExtensions}  ^  Server
                                   {CertificateRequest*}  v  Params
                                           {Certificate}  ^
                                     {CertificateVerify}  | Auth
                                              {Finished}  v
                          <--------  [Application Data*]
~~~

The LURK client on the TLS server initiates a schedule context (ks_ctx)
and sends an InitCertificateVerifyRequest to the LURK server. As this is
an initial exchange of a LURK session, the context ID ctx_id is set to
init_id. In our example, key_request sets the handshake and application
secrets. handshake_context is set to ClientHello ... later of server
EncryptedExtensions / CertificateRequest. In our case the TLS server
does not intend to authenticate the TLS server, so handshake_context is
set to ClientHello ... EncryptedExtensions. ephemeral_secret is provided
to generate the ECDHE secret, key_id, sig_algo, serctificate are
provided to generate CertificateVerify. 

~~~
TLS Server                      
Lurk Client                              Cryptographic Service
        InitCertificateVerifyRequest
            ctx_id=init_id
            key_request
            handshake_context
            ephemeral_secret
            key_id, 
            sig_algo 
            certificate               -------->
                                         InitCertificateVerifyResponse
                                            keys, certificate_verify
                                   <---------   finished
~~~

The necessary Handshake Context to generate the handshake secrets are
ClientHello...ServerHello  which are provided by the handshake_context.

The generation of the CertificateVerify is described in {{!RFC8446}}
section 4.4.3. and consists in a signature over a context that includes
the output of Transcript-Hash(Handshake Context, Certificate) as well as
a context string. Both Handshake Context and context string depends on
the Mode which is set to server in this case via the configuration of
the LURK server. 

The necessary Handshake Context to generate the CertificateVerify is
ClientHello ... later of EncryptedExtensions / CertificateRequest. In
our case, this is exactly handshake_context, that is ClientHello ...
EncryptedExtensions.   

Once the certificate_verify value has been defined, the LURK server
generates the server Finished message in order to have the necessary
Handshake Context ClientHello...server Finished to generate the
application secrets. 


The LURK server returns the requested keys, the certificate_verify and
the finished message so the TLS server can complete the ServerHello
response.   

As session resumption is not provided, teh LURK server goes into a
finished state and delete the ks_ctx. 

### TLS client: client Finished (#sec:ecdhe-no-resumption-client-finished}

Upon receiving the ServerHello message, the TLS client retrieve the
handshake and application secrets to decrypt the messages receives from
server as well as to encrypt its own messages and application data as
represented below:

~~~
TLS Client                                   TLS Server

      {Finished}              -------->
      [Application Data]      <------->  [Application Data]
~~~



To retrieves these secrets, the TLS client proceeds successively to an
HandshakeSecretRequest followed by a AppSecretRequest. 

~~~
TLS Client                      
Lurk Client                              Cryptographic Service
        HandshakeSecretRequest
            ctx_id=init_id
            key_request
            handshake_context
            ephemeral_secret
            ------->

                                  HandshakeSecretResponse
                           <--------  keys
TLS Client                      
Lurk Client                              Cryptographic Service
        AppSecretRequest
            ctx_id=opaque
            key_request
            handshake_context
            ephemeral_secret
            ------->

                                  AppSecretResponse
                           <--------  keys
~~~

As the HandshakeSecretRequest initiates a session between the LURK
client and the LURK server, the context ID is set to init_id while next
request have their context ID set to opaque. key_request is set to
handshake secrets only. handshake_context is set to ClientHello ...
ServerHello (with ctx_id of type init_id). ephemeral_secret is provided
to the Cryptographic Service to generate the ECDHE sercet. 

The necessary Handshake to generate handshake secrets is
ClientHello...ServerHello which is provided by the handshake_context. 

Upon receiving the HandshakeSecretRequest with a ctx_id type of init_id,
and no PSK provided, the Cryptographic Service initializes a key
schedule context ks_ctx and computes the handshake_secrets from ECHDE,
PSK, Hash function. Since no client authentication is expected, the
next_request is set to app_secret. It thene return the handshake secrets
to the LURK client. 

The TLS client decrypt the encrypted messages of teh ServerHello
exchange. As no CertificateREquest appears, the LURK client initiates a
AppSecretRequest to decrypt and encrypt application data while finishing
the TLS handshake. key_request is limited to the application secrets.
The handshake_context is set to server EncryptedExtensions ... server
Finished.  

Upon receiving the AppSecretRequest, the Cryptographic Service checks
the request is expected by checking the ctx_id and the request type. The
Cryptographic Service has now the ClientHello ... server Finished which
enables it to compute the application secrets. 

As no session resumption is provided, the Cryptographic Service and the
LURK client goes into a finished state and delete their ks_ctx. 

## TLS 1.3 Full Handshake with ECDHE authentication only and session resumtpion, no TLS client authentication  {#sec:ecdhe-resumption}

This scenario considers that the TLS server is authenticated using ECDHE
only in the first time and that further TLS handshake use the session
resumption mechanism. The first TLS Handshake is very similar as the
previous one. The only difference is that psk_key_exchange_mode
extension is added to the ClientHello. However, as no PSK identity is
provided, the Full exchange is performed as described in section
{{(sec:ecdhe-no-resumption}}.  

The only change is that session resumption is activated, and thus LURK
client and LURK servers do not go in a finished state and close the LURK
session after the exchanges are completed. Instead further exchanges are
expected. In the case where session resumption is enabled, the
next_request of the ks_ctx is set to nes_session_request. 



### Full Handshake {#sec:ecdhe-session-resumption-fullhandshake}


The Full TLS Handshake use ECDHE authentication. It is very similar to
the logic described in section {{(sec:ecdhe-no-resumption}}. The TLS
handshake is specified below for convenience. 

~~~
TLS Client                                   TLS Server

    Key  ^ ClientHello
    Exch | + key_share 
         | + psk_key_exchange_mode
         v + signature_algorithms ---------> 
                                             ServerHello  ^ Key
                                             + key_share  | Exch
                                   {EncryptedExtensions}  Server Param
                                           {Certificate}  ^
                                     {CertificateVerify}  | Auth
                                              {Finished}  v
                          <--------  [Application Data*]
      {Finished}              -------->
      [Application Data]      <------->  [Application Data]
~~~

### TLS server: NewSessionTicket {#sec:ecdhe-session-resumption-newsessionticket}

As session resumption has been activated by the psk_key_exchange_mode,
the TLS Server is expected to provid ethe TL Sclient NewSessionTickets
as mentionned below:

~~~
TLS Client                                   TLS Server
                          <--------      [NewSessionTicket]
~~~


The LURK client and  LURK server on the TLS server does not go into a
finished state. Instead, the LURK client continue the LURK session with
a NewSessionTicketRequest to enable the Cryptographic Service to
generate the resumption_master_secret necessary to generate the PSK and
generate a NewTicketSession. ctx_id is of type opaque, ticket_nbr
indicate sthe number of NewSessionTickets and handshake_context is set
to earlier of client Certificate client CertificateVerify ... client
Finished. As we do not consider TLS client authentication, the
handshake_context is set to client Finished as represented below. 

~~~
TLS Server                      
Lurk Client                              Cryptographic Service
        NewSessionTicketRequest
            ctx_id=ctx_id
            ticket_nbr
            handshake_context=client Finished  -------->
                                         NewSessionTicketResponse
                                   <---------   tickets
~~~

The necessary Handshake Context to generate the resumption_master_secret
is ClientHello...client Finished. From the InitCerificateVerify the
context_handshake was set to ClientHello...server Finished. The
additional handshake_context enables the Cryptographic Service to
generate the NewSessionTickets.  

Note that the LURK client on the TLS server may send multiple
NewSessionTicketRequest. Future request have an emptpy
handshake_context.

Upon  receiving the NewSessionTicketRequest, the LURK server checks the
ctx_id as well as if the request type matches the ks_ctx.next_request.
It then generates the resumption_master_secret, NewSessionTickets.
NewSessionTickets are stored into the PSK_DB under
NewSessionTicket.ticket. Note that PSK is associated with the
authentication mode as well as the Hash K server responds with
NewSessionTickets that are then transitted back to the TLS client. The
TLS server is ready for session resumption. 

### TLS client: NewSessionTicket {#sec:ecdhe-session-resumption-newsessionticket}

Similarly, the LURK client on the TLS client will have to provide
sufficient information to the Cryptographic Service the necessary PSK
can be generated in case of session resumption. This includes the
remaining Handshake Context to generate the resumption_master_secret as
well as NewSessionTickets provided by the TLS server. The LURK client
uses the RegisterSessionTicket message. 


Note that the LURK client may provide the handshake_context with an
empty list of NewSessionTickets, and later provide the NewSessionTickets
as they are provided by the TLS server. The Handshake Context only needs
to be provided for the first RegisterSessionTicket. 

~~~
TLS Client                      
Lurk Client                              Cryptographic Service
        NewSessionTicketRequest
            ctx_id=ctx_id
            handshake_context=client Finished  
            ticket_list            -------->
                                         NewSessionTicketResponse
                                   <---------   tickets
~~~


Both TLS client and TLS Servers are ready for further session
resumption. On both side the Cryptographic Service stores the PSK in a
database designated as PSK_DB. Each PSK is associated to a Hash function
as well as authentication modes. Each PSK is designated by an identity.
The identity may be a label, but in our case the identity is derived
from the NewSessionTicket.ticket.    

### Session Resumption {#sec:session-resumption}

Session resumption is initiated by the TLS client. Session resumption is
based on PSK authentication and different PSK may be proposed by the TLS
client. The TLS handshake is presented below.  

~~~
TLS Client                                   TLS Server
       ClientHello
       + key_share
       + psk_key_exchange_mode
       + pre_shared_key          -------->
                                                       ServerHello
                                                  + pre_shared_key
                                                      + key_share
                                             {EncryptedExtensions}
                                                        {Finished}
                                 <--------     [Application Data*]
~~~

The TLS client may propose to the TLS Server multiple PSK. Each of these
PSK is associated a PskBindersEntry defined in {{!RFC8446}} section
4.2.11.2. PskBindersEntry is computed similarly to the Finished message
using the binder_key and the partial ClientHello. 

The TLS server is expected
to pick a single PSK and validate the binder. In case the binder does
not validate the TLS Handshake is aborted. As a result, only one
binder_key is expected to be requested by the TLS server as opposed to
the TLS client. 

In this example we assume the psk_key_exchange_mode indicated the TLS
client supports PSK-ECDHE as well as PSK authentication. The presence of
a pre_shared_key and a key_share extension in the ServerHello inidcates
that PSK-ECDHE has been selected.  


#### TLS client: ClientHello 

To compute binders, the TLS Client needs to request the binder_key
associated to each proposed PSK. These binder_keys are retrieved to the
Cryptographic Service using the BinderKeyRequest. A new ks_ctx is
created thus the ctx_ix is of type init_id which contains the PSK
identity (PSKIdentity.identity or NewSessionTicket.ticket.). key_request
is set to binder_key and the handshake_context is empty.  

~~~
TLS Client                      
Lurk Client                              Cryptographic Service
        BinderKeyRequest
            ctx_id=init
            key_request=binder_key
            handshake_context=""
                                         BinderKeyResponse
                                   <---------   key
~~~

Upon receiving the BinderKeyRequest, the Cryptographic Service checks
the psk is in the PSK_DB initiates a key schedule context (ks_ctx) and
returns binder_key. 

With the binder keys, the TLS Client is able to send it ClientHello
message. Note that the usage of multiple PSK may lead to the creation of
multiple ks_ctx. The LURK client will be able to define which PSK has
been selected by the TLS server, but that information is not provided to
the LURK server. As a result, the LURK server is expected to set a
timeout after which the ks_ctx is deleted. 


#### TLS server: ServerHello

The TLS server is expected to select a PSK, checks the associated binder
and proceed further. If the binder fails, it is not expected to proceed
to another PSK, as a result, the TLS server is expected to initiates a
single LURK session. 

The binder_key is requested by the TLS server via and
EarlySecretRequest. In our case, only the binder_key is requested so
key_request is set to binder_key only. Similarly, to the TLS client, the
handshake_context is not needed to generate the binder_key. However, the
EarlySecret exchange requires the ClientHello to be provided so early
secrets may be computed in the same round during 0-RTT handshake. 

~~~
TLS Server                      
Lurk Client                              Cryptographic Service
        EarlySecretRequest
            ctx_id=init_id
            key_request=binder_key
            handshake_context=ClientHello
                                         EarlySecretResponse
                                   <---------   key
~~~

To complete to the ServerHello exchange, the TLS server
needs the handshake and application secrets. These secrets are requested
via an HandshakeAndAppSecret. ctx_id is of type opaque and the
handshake_context is set to ServerHello ... later of server
EncryptedExtensions / CertificateRequest. In our case, this the
handshake_context is set to ServerHello ... EncryptedExtensions. 

The necessary Handshake Context to generate the handshake secrets is
ClientHello ... ServerHello, so the Cryptographic Service can generate
the handshake secrets. The necessary handshake context to generate the
application secrets is ClientHello ... server Finished. So the
Cryptographic Service needs to generate the Finished message before as
in the case of the InitCerificateVerify exchange  detailled in
{{sec:ecdhe-session-resumption-fullhandshake}}.  


~~~
TLS Server                      
Lurk Client                              Cryptographic Service
        HandshakeAndAppRequest
            ctx_id=ctx_id
            key_request
            handshake_context
            ephemeral_secret          -------->
                                         HandshakeAndAppResponse
                                            keys, finished
                                   <---------   finished
~~~

The Cryptographic Service returns the necessary secret to the TLS server
to complete the ServerHello response. 

The remaining of the TLS handshake is proceeded similarly as described
in the Full Handshake in section {{sec:ecdhe-resumption}}.  



## 0-RTT handsahke

The 0-RTT Handshake is a PSK or PSK-ECDHE authentication that enables
the TLS client to provide application data during the first round trip.
The main differences to the PSK PSK-ECDHE authentication described in
the case of session resumption is that:

* Application Data is encrypted in the ClientHello based on the
client_early_secret
* Generation of the client_early_secret requires the Cryptographic
Service to be provisioned with the ClientHello which does not need to be
re-provisioned later to generate the handshake secrets 
* An additional message EndOfEarlyData needs to be considered to compute
the client Finished message.   

~~~
TLS Client                                   TLS Server

       ClientHello
       + early_data
       + key_share*
       + psk_key_exchange_modes
       + pre_shared_key
       (Application Data*)     -------->
                                                       ServerHello
                                                  + pre_shared_key
                                                      + key_share*
                                             {EncryptedExtensions}
                                                     + early_data
                                                        {Finished}
                               <--------       [Application Data*]
       (EndOfEarlyData)
       {Finished}              -------->
       [Application Data]      <------->        [Application Data]
~~~

### TLS client: ClientHello

With 0-RTT handshake, the TLS client builds binders as in session
resumption described in section {{sec:session-resumption}}. The
binder_key is retrieved for each proposed PSK with a BinderKeyRequest.
When early application data is sent it is encrypted using the
client_early_traffic_secret. This secret is retrieved using the
EarlySecretRequest. The ctx_id type is set to opaque as the ks_ctx has
already been established by the BinderKeyRequest. The key_request is set
to client_early_traffic_secret and the handshake_context is set to
ClientHello. 

When multiple PSK are proposed by the TLS client, the first proposed PSK
is used to encrypt the application data.

~~~
TLS Client                      
Lurk Client                              Cryptographic Service
        EarlySecretRequest
            ctx_id=opaque
            key_request=client_early_traffic_secret
            handshake_context=ClientHello
                                         EarlySecretResponse
                                   <---------   keys=client_early_traffic_secret
~~~

Upon receiving the EarlySecretRequest, the Cryptographic Service
generate the client_early_traffic_secret. The Cryptographic checks the
ctx_id and the request type against the ks_ctx.next_request before
generating the early secret. 

The TLS client is able to send its ClientHello with associated binders
and application data.  

### TLS server: ServerHello

If the TLS server accepts the early data. It proceeds as described in session
resumption described in section {{sec:session-resumption}}. In addition
to the binder_key, the TLS server also request the client_early_traffic_secret
to decrypt the early data as well as to proceed to teh ServerHello
exchange.


### TLS client: Finished

The TLS client proceeds as described in handshake based on ECDHE, PSK or
PSK-ECDHE authentications described in
{{sec:ecdhe-no-session-resumption}} and
{{sec:ecdhe-session-resumption}}. The main difference is that upon
requesting handshake and application secrets, using an HandshakeRequest
the TLS client will not provide the ClientHello as part as the
handshake_context. The Client as already been provided during the
EarlySercret exchange. 


## TLS client authentication

TLS client authentication can be performed during the Full TLS handshake
or after the TLS handshake as a post handshake authentication. In both
cases, the TLS client authentication is initiated by the TLS server
sending a CertificateRequest. The authentication is performed via a
CertificateVerify message generated by the TLS client but such
verification does not involve the Cryptographic Service on the TLS
server. 

## TLS Client:Finished (CertificateRequest) 

The ServerHello MAY carry a CertificateRequest encrypted with the
handshake sercets. 

Upon receiving the ServerHello response, the TLS client decrypts the
ServerHello response. If a CertificateRequest message is found, the TLS
Client requests the Cryptographic to compute the CertificateVerify in
additional to the application secrets via a CertificateVerifyRequest.
The ctx_id is of type opaque, the key_request are set to the application
secrets and the handshake_context is set to server EncryptedExtensions
... later of server Finished/EndOfEarlyData. As the resquest follows a
(BinderKey, EarlySecret, HandshakeSecret) or HandshakeSecret the
Handshake Context on the Cryptographic Service now becomes: ClientHello
... later of server Finished/EndOfEarlyData which is the Handshake
Context required to generate the CertificateVerify on the TLS client
side and includes the Handshake Context required to generate the
application secrets (ClientHello...server Finished).  


~~~
TLS Client                      
Lurk Client                              Cryptographic Service
        CertificateVerifyRequest
            ctx_id=opaque
            key_request
            handshake_context
                                         CertificateVerifyResponse
                                   <---------   keys, certificate_verify
~~~

Upon receiving the EarlySecretRequest, the Cryptographic Service checks
the ctx_id and ks_ctx.next_request matches the incoming request,
generates secrets and certificate_verify data. The ks_ctx.next_request
is updated to [register_session_tickets, post_handshake].  


## TLS Client Authentication (PostHandshake)

When post-handshake is enabled by the TLS client, the TLS client may
receive at any time after the handshake a CertificateRequest message.
When post handshake is enabled by the TLS client, as soon as the client
Finished message has been sent, the TLS client sends a
RegisteredNewSessionTicketRequest with an empty NewSessionTicket to register
the remaining Handshake Context to the Cryptographic Service. ctx_id is
set to opaque, handshake_context is set to earlier of client Certificate
client CertificateVerify ... client Finished.

Upon receiving the RegisteredNewSessionTicketsRequest the Cryptographic
is aware of the full Handshake Context.
It updates ks_ctx.next_request
to [post_handshake, register_session_ticket].

~~~
TLS Client                      
Lurk Client                              Cryptographic Service
        RegisteredNewSessionTicketRequest
            ctx_id=opaque
            handshake_context
            ticket_list (empty)
                  <--------- RegisteredNewSessionTicketResponse
~~~

When the TLS client receives a CertificateRequest message from the TLS
server, the TLS client sends a PostHandshakeRequest to teh Cryptographic
Service to generate certificate_verify.ctx_id is of type opaque and teh
handshake_context is set to CertificateRequest. The
index N of the client_application_traffic_N key is provided as well as the
Cryptographic so it can generate the appropriated key. 

~~~
TLS Client                      
Lurk Client                              Cryptographic Service
        PostHandshakeRequest
            ctx_id=opaque
            handshake_context=CertificateRequest
            app_n=N
                                         PostHandshakeResponse
                                   <---------   certificate_verify
~~~

Upon receiving the PostHandshakeRequest the Cryptographic Service checks
ctx_id and match the request to ks_ctx.next_request. The necessary
Handshake Context to generate the certificate_verify is ClientHello ...
client Finished + CertificateRequest. Once the PostHandshakeResponse has
been sent, it updates ks_ctx.next_request to [post_handshake,
register_session_ticket].

