---
title: LURK Extension version 1 for (D)TLS 1.3 Authentication
abbrev: LURK/TLS 1.3
docname: draft-mglt-lurk-tls13-00


area: Security
wg: LURK
kw: Internet-Draft
cat: std

coding: us-ascii
pi:
  rfcedstyle: yes
  toc: yes
  tocindent: yes
  sortrefs: yes
  symrefs: yes
  strict: yes
  comments: yes
  inline: yes
  docmapping: yes

author:
      -
        ins: D. Migault
        name: Daniel Migault
        org: Ericsson
        street: 8275 Trans Canada Route
        city: Saint Laurent, QC
        code: 4S 0B6
        country: Canada
        email: daniel.migault@ericsson.com


--- abstract

This document describes the LURK Extension 'tls13' which enables
interactions between a LURK Client and a LURK Server in a context of
authentication with (D)TLS 1.3.

--- middle


# Introduction {#sec-intro}

This document defines a LURK extension for TLS 1.3 {{!RFC8446}}. 

This document assumes the reader is familiar with TLS 1.3 the LURK
architecture {{?I-D.mglt-lurk-lurk}}. 

The motivations for the LURK Extension TLS 1.3 are similar to those for
the LURK extension of TLS 1.2 {{?I-D.mglt-lurk-tls12}} and the LURK use
cases {{?draft-mglt-lurk-use-cases}}.   

Interactions with the Cryptographic Service can be performed by the TLS
Client as well as by the TLS Server. 

LURK defines an interface to a Cryptographic Service that stores the
security credentials - Typically a provisioned PSKs and certificate
private keys - use for the authentication. These credentials are
typically involved in the computation of the signature of the
CertificateVerify, the key schedule to derive the necessary keys
({{!RFC8446}} section 7.1. Some of these keys (resumption_master_secret)
are in turn used to generate PSK for session resumption and as such
require similar protections as the PSK itself. 
 
As a result, the Cryptographic Service will mostly consists in
performing the key schedule while providing necessary information to the
TLS Engine to accomplish the handshake or for future session resumption.
This typically includes:
* retrieving [sender]_handshake_traffic_secret to encrypt/decrypt the
handshake extensions and messages
[sender]_application_traffic_secret_0 to encrypt/decrypt application
data,  exporter_master_secret to export the master secret.
* retrieving necessary information to proceed to the authentication such
as the generation of the signature of the CertificateVerify
* retrieve NewSessionTicket so a reference to a PSK can be provided in
the future, typically to perform session resumption. 

Note that the key schedule may require some some computation and the
generation of information that may be useful to the TLS Engine. In this
case, such information is provided to avoid as much as possible the
computation to be performed twice. This is the case for the Finished
message. The Finished message must be computed to perform the key
schedule. As a result, it is provided in addition to the
[sender]_handshake_traffic_secret as to avoid the sender to compute it
again.    

# LURK Header {#sec-lurk-tls-header}

LURK / TLS 1.3 is a LURK Extension that introduces a new designation
"tls13". This document assumes that Extension is defined with
designation set to "tls13" and version set to 1. The LURK Extension
extends the LURKHeader structure defined in {{?I-D.mglt-lurk-lurk}} as
follows:

~~~
enum {
    tls13 (2), (255)
} Designation;

enum {
   capabilities (0), ping (1), rsa_master (2),
   rsa_extended_master (3), ecdhe (4), (255)
}TLS13Type;


enum {
    // generic values reserved or aligned with the
    // LURK Protocol
    request (0), success (1), undefined_error (2),
    invalid_payload_format (3),

    //code points for ecdhe authentication
    invalid_ec_type (9), invalid_ec_curve (10),
    invalid_poo_prf (11), invalid_poo (12), (255)
}TLS13Status

struct {
     Designation designation = "tls12";
     int8 version = 1;
} Extension;

struct {
    Extension extension;
    select( Extension ){
        case ("tls13", 1):
            TLS12Type;
    } type;
    select( Extension ){
        case ("tls13", 1):
            TLS13Status;
    } status;
    uint64 id;
    unint32 length;
} LURKHeader;
~~~


# handshake_server_key

This exchange is only expected to be performed by a TLS Client. The
server_handshake_key is necessary for the TLS Client to decrypt the
handshake message/extensions encrypted by the TLS Server. 

Interaction with a Cryptographic Service is required when the PSK is
protected by the Cryptographic Service. 

TLS 1.3 defines various key exchange modes (ke_mode): (EC)DHE (dhe_ke) as well as
modes that involves a PSK, PSK-only (psk_ke) and PSK in combination of
(EC)DHE (psk_dhe_ke). psk_dhe and psk_ke are defined in {{!RFC8446}}
section 4.2.9 in the PskKeyExchangeMode structure. dhe_ke corresponds to
the absence of that structure. 


## Request Payload {#hsk-req}
~~~

enum { sha256 (0), (255) } TranscriptHash; 

enum { psk_raw (0), psk_ticket (1), (255) } PSKType;

enum { dhe_ke(0), psk_ke(1), psk_dhe_ke(2) (255)} KeyExchangeMode;

struct {
    PSKType psk_type;
    select( psk_type ){
        case raw_psk :
            opaque raw_psk<0..2^16-1>;
        case identity_psk : 
            OfferedPsks offered_psk  // {{!RFC8446}} section 4.2.11
} PSK

struct {
    select ( ke_mode ){ 
        case psk_ke :
            PSK psk
        case psk_dhe_ke :
            PSK psk
            NamedGroup dh_group; // {{!RFC8446}} section 4.2.7
            opaque dhe_secret<1..2^16-1>;
        case dhe_ke:
            NamedGroup dh_group; // {{!RFC8446}} section 4.2.7
            opaque dhe_secret<1..2^16-1>;
    }
} KeyScheduleInputSecrets 


enum { 
    sha256 (0) (255)
} PFSAlgorithm

struct {
    PFSAlgorithm freshness_funct;  // {{!I-D.mglt-lurk-tls12}} section 4.1
    TranscriptHash h;
    KeyExchangeMode ke_mode // {{!RFC8446}} section 4.2.9
    opaque handshake_context<0..2^32-1>
    KeyScheduleInputSecrets secrets
} HandshakeServerKeyRequest
~~~

psk_type
: indicates how the PSK is provisioned to initiate the key schedule as
described in {{!RFC8446}} section 7.1. The type psk_raw
indicates the PSK is explicitly provided. The type psk_ticket indicates
the PSK is generated from the ticket as described in
{{!RFC8446}} section 4.6.1.

freshness_funct
: the one-way hash function (OWHF) used by LURK to implement
Perfect Forward Secrecy.

h
: the hash function used by the Transcript-Hash {{!RFC8446}}
section 4.4.1.

offered_psk
: reuses the  OfferedPsks described in {{!RFC8446}} section
4.2.11. The PSK structure only allow a single PSK, thus OfferedPsks MUST
represent a single PSK.
  
ke_mode 
: defines pre shared key exchange defined in {{!RFC8446}}
section 4.2.9. It indicates whether the key exchange considers a (EC)DHE key
establishment or not in addition to the PSK. 

dh_group 
: reuses the structure NamedGroup of {{!RFC8446}} section
4.2.7 to indicate the curve or the group used in (EC)DHE key
establishment. 

handshake_context 
: the necessary handshake context to generate the key as described in
{{!RFC8446}} section 7.1. The handshake_context MUST be
ClientHello...ServerHello.

secrets
: the necessary secret inputs (PSK, (EC)DHE) secret necessary for the
key schedule of {{!RFC8446}} section 7.1.


## Response Payload

~~~
struct {
    opaque server_handshake_key<0..2^32-1>
} HandshakeServerKeyResponse
~~~

server_handshake_key
: the server_handshake_key

## LURK Client Behavior {#hsk-clt}


The TLS Client establishing a TLS session with a TLS Server receives
from the TLS Server a ServerHello message with additional encrypted
messages such as the EncryptedExtensions, the Finished as well as the
optional Certificate, CertificateVerify and Application Data message. The
TLS Client needs to retrieve the server_handshake_key in order to
decrypt these messages.  

With ServerHello as the input message, the LURK Client initiates the
exchange as described below:

Perfect Forward Secrecy Setting:

* Perfect Forward Secrecy is performed as described in
{{!I-D.mglt-lurk-tls12}} section 4.1.1 over the client_random. There is
no gmt_unix_time as such ServerHello.random is generated as follows:
~~~
ClientHello.random = freshness_funct( client_random + "tls13_c freshness_funct" );
~~~

Transcript Hash Setting:

* the value for transcript hash is provided by the configuration.

PSK Key Exchange Mode Setting:

* if  the input message does not contains any key_share extension, the
LURK Client sets ke_mode to psk_ke. 
* if  a key_share extension is present the LURK Client sets ke_mode to
psk_dhe_ke. 

Key Schedule Input Secret Setting:

* if the input message  has no pre_shared_key extension, the LURK Client
sets psk_type to psk_raw with a psk of length 0. 
* if the input message has a pre_shared_key extension, the LURK Client
provides the PSK that is not a PSK of zero length, as follows:
..* the PSK is provided explicitly by using the psk_type set to psk_raw
with the explicit value of the PSK. This alternative is NOT RECOMMENDED,
as it means the PSK is not known by the Cryptographic Service and is
known outside this service. It may happen when the TLS Client is
configured with a PSK while the Cryptographic Service is not provisioned with
that PSK. The case where the PSK is provided for a session resumption is
outside the scope of this document as the session_resumption_secret is
never shared outside the Cryptographic Service.
..* the PSK is provided via NewSessionTicket. Upon receiving a
selected_identity in the pre_shared_key extension, the LURK Client
selects the corresponding local_ticket previously provided by the LURK
Server during the previous handshake. local_ticket are internal
structure used by LURK detailled in {{local_ticket}}
 

## LURK Server Behavior {#hsk-srv}

Upon receiving a handshake_server_key request, the LURK server proceeds
as follows:

Perfect Forward Secrecy Check:

* if freshness_funct is not supported, an invalid_freshness_funct erroro is returned. 
* ClientHello.random is generated as described in {{hsk-clt}} and
the value is provided in handshake_context.

Transcript-Hash Check: 

* if h is not a supported transcript-hash
function and invalid_transcript_hash error is returned.

Handshake Check:

* if handshake does not contains a ClientHello...ServerHello an
invalid_handshake error is returned.


PSKExchangeMode Check: 

* if ke_mode is not supported an invalid_ke_mode error is returned.

KeyScheduleInputSecret Check check the validity of the secrets as well
as the coherence wit the pre shared key exchange. These checking
operations are subdivided into (EC)DHE Check and PSK Check operations: 

(EC)DHE Check:

* if ke_mode is set to psk_dhe_ke and secret does not contain a (EC)DHE
secret an invalid_secret error is returned.  
* if the (EC)DHE secret does not match the expected length or the curve
is not supported an invalid_ecdhe_secret error is returned.

PSK Check:

* if the psk type is not supported a invalid_psk_type is returned. 
* if psk_type is psk_raw and the format of the psk is unexpected an
invalid_psk_format error is returned.
* if the psk_type is psk_ticket:

..* if the number of psk or associated binder is more than 1, an
invalid_ticket_format error is returned
..* there is no corresponding identity, an invalid_psk_ticket error is returned. 
* if the psk_type is identity_psk binder_key is generated as described
in {{!RFC8446}} section 7.1.
..* if the binder associated to the psk does not match the one provided
in the offered_psk and invalid_binder error is returned. The binder is
computed as described in {{!RFC8446}} section 4.2.11.2. with
the binder_key generated as described in {{!RFC8446}} section
7.1.

Key Generation:

* server_handshake_key is generated as described in
{{!RFC8446}} section 7.1 and returned to the LURK Client. 


# auth

This exchange provides interactions with a Cryptographic Service both on
the TLS Client side as well as the TLS Server side. 

The pupose of teh exchange is to obtain a CertificateVerify, the
Finished message as well as the necessary keys to encrypt/decrypt the
handshake messages as well as the application data. 

Note the Finished message does not involve any private key nor PSK. As a
result, it does not need to be performed within the Cryptographic
service in order to protect the security credentials. On the other hand,
the Cryptographic Service is responsible to perform the key scheduling
and deliver the 
Cryptographic Service, however, the Cryptographic Service computes the
CertificateVerify message  

## Request Payload {#auth-req}


~~~
enum { server (0), client (1), post-handshake (2) } HandshakeMode; 

struct {
    PFSAlgorithm freshness_funct;  // {{!I-D.mglt-lurk-tls12}} section 4.1
    TranscriptHash h;  // c, f
    KeyExchangeMode ke_mode // {{!RFC8446}} section 4.2.9
    select( ke_mode ){
        case : psk_dhe_ke, dhe_ke
        KeyPairID key_id // {?draft-mglt-lurk-tls12} section 3.
----- KeyID??            Certificate certificate        // {{!RFC8446}} section 4.4.2
            SignatureScheme sig_algo     // {{!RFC8446}} section 4.2.3.
    }
    HandshakeMode handshake_mode        // c, f
    opaque handshake_context<0..2^32-1> // c, f
    KeyScheduleInputSecrets secrets // f
    uint8 key_request
    uint8 ticket_number
} AuthRequest

c: structure used for the CertificateVerify message
f: structure used for the Finished message
~~~

freshness_funct, h, ke_mode, handshake_context and secrets are define in {{hsk-req}}

---certificate 
---: end point certificate defined in {{!RFC8446}} section
---4.4.2.

key_id: 
designation of the private key as defined in {{?draft-mglt-lurk-tls12}}
section 3.

algorithm
: signature algorithm used defined in {{!RFC8446}} section 4.2.3.

handshake_mode
: defines the specific Handshake Context and Base Key necessary to
compute authentication messages as defined in {{!RFC8446}}
section 4.4. The handshake_mode set to server indicates the LURK
exchange is performed by the TLS Server while the handshake_mode set to
client or post-handshake indicates the LURK exchange is performed by the
TLS Client. 

handshake_context 
: Handshake Context has defined in {{!RFC8446}} section 4.4.

key_request
: indicates optional requested keys. The bit is set to 1 to indicate the
key is being requested by the LURK Client.
..* bit 0 : binder_key
..* bit 1 : client_early_traffic_secret
..* bit 2 : early_exporter_master_secret 
..* bit 3 : client_handshake_traffic_secret
..* bit 4 : server_handshake_traffic_secret
..* bit 5 : client_application_traffic_secret_0
..* bit 6 : server_application_traffic_secret_0
..* bit 7 : exporter_master_secret

ticket_number 
: indicates the expected number of session resumption tickets. When
requested by the TLS Client the ticket_number is expected to be 0 or 1.
When requested by the TLS Server the number can be larger. 

## Response Payload

~~~
struct{
    opaque key<0..2^16-1>
} Key 

struct {
    uint8 key_index
    opaque key_list<0..2^32-1>
} Keys

struct {
    Keys keys
    CertificateVerify certificate_verify
    Finished finished
    NewSessionTicket ticket_list<0..2^32-1> 
} AuthResponse
~~~

key_index
: follows the same syntax as key_request in {{auth-req}}.

key_list 
:the list of keys indicated by key_index.

ticket_list 
: list of NewTicketSessions


## LURK Client Behavior (TLS Server) {#auth-clt-srv_tls}

On a TLS Server, the LURK Server initiates the LURK exchange after
receiving the ClientHello from the TLS Client. The purpose of this
exchange is to retrieve the CertificateVerify, Finished, and the
necessary keys to:

* encrypt the EncryptedExtensions, Finished and optional
CertificateRequest Certificate and CertificateVerify message:
server_handshake_traffic_secret
* encrypt the optional Application Data message:
server__application_traffic_secret_N
* decrypt the future Finished or optional Certificate and
CertificateVerify message sent by the TLS Client:
client_handshake_traffic_secret. 
* decrypt the future Application Data message with the 
client__application_traffic_secret_N

Perfect Forward Secrecy Setting:

* Perfect Forward Secrecy is performed as described in
{{!I-D.mglt-lurk-tls12}} section 4.1.1 over the server_random. There is
no gmt_unix_time as such ServerHello.random is generated as follows:
~~~
ServerHello.random = freshness_funct( server_random + "tls13_s freshness_funct" );
~~~


The LURK Client proceeds to the Transcript Hash Setting
PSK Key Exchange Mode Setting and the Key Schedule Input Secret Setting
as described in {{hsk-clt}}. 

Handshake Mode Setting:

* If the LURK Client sets the handshake_mode to "server". 

Handshake Setting:
The handshake is set as described in {{!RFC8446}} section
4.4.

Key Request Setting:

* key_request MUST have the Bit 0 and Bit 1 set to retrieve the
[sender]_handshake_traffic_secret. 
* key_request MUST have the Bit 2 and Bit 3 set to retrieve the
[sender]_application_traffic_secret_N
* Key_request MAY have Bit 4 set if there is a need to use the extractor. 

Upon receiving the AuthResponse, the TLS Server encrypts the messages
and pursue the TLS handshake as defined in {{!RFC8446}}. 


## LURK Client Behavior (TLS Client)

On a TLS Client the LURK Client initiates an AuthRequest in order to
compute the Finished and optional CertificateVerify as well as to
retrieve the necessary keys to:

* encrypt the Finished and optional Certificate and CertificateVerify
message: client_handshake_traffic_secret
* encrypt the optional Application Data message:
server__application_traffic_secret_N
* decrypt the future Application Data message with the
server__application_traffic_secret_N

The TLS Client has decrypted the encrypted handshake messages sent by
the TLS Server by retrieving the server_handshake_traffic_secret with an
HandshakeServerKeyRequest.


The LURK Client proceeds to Perfect Forward Secrecy Setting, Transcript
Hash Setting, Key Schedule Input Secret Setting as described in
{{hsk-clt}}. 

If the TLS Client has received a CertificateRequest from the TLS Server,
the LURK Client:

* sets the ke_mode to psk_dhe_ke. Note that the value is not correlated
to the value agreed psk_key_exchange_modes between the TLS Client and
the TLS Server. Instead it indicates the necessity to generate a
CertificateVerify. 
* provides the Certificate associated to the private key of the TLS


Handshake Mode Setting:

* If the LURK Client is initiating a LURK exchange on behalf of a TLS
Client it sets the handshake_mode to:
..* "client" when the LURK exchange occurs during the TLS handshake.
..* "post-authentication" when the LURK exchange occurs outside the TLS
handshake. 

Handshake Setting:

* set handshake_context as defined in {{!RFC8446}} section 4.4.

Key Request Setting:

* key_request SHOULD have the Bit 0 unset, as
client_handshake_traffic_secret is already known by the TLS Client 
* key_request MUST have the Bit 1 set to retrieve the
server_handshake_traffic_secret. 
* key_request MUST have the Bit 2 and Bit 3 set to retrieve the
[sender]_application_traffic_secret_N
* Key_request MAY have Bit 4 set if there is a need to use the extractor. 

Ticket Number Setting:

* If the TLS Client want to performed further session resumption,
ticket_number is set to 1 and 0 otherwise.


Upon receiving the AuthResponse, the LURK Client has the necessary
information to proceed the TLS handshake.  The ticket_list is a list of
local_ticket. The list MUST have a maximum of one local_ticket. The LURK
Client is expected to manage the local_tickets as described in
{{local_ticket}}


### Local Ticket {#local_ticket}

local_ticket re-uses the NewSessionTicket structure in two different
ways depending if the LURK exchange is initiated by a TLS Client or by a
TLS Server. 

* ticket provided to the TLS Server (by the LURK Server)  are
new_session_ticket, expected to be forwarded to the TLS Client.
* tickets provided to the TLS Client ( by the LURK Server) are
local_ticket. These local_tickets are only expected to be used between
the LURK Client and the LURK Server of the TLS Client.    

During the initial handshake, the TLS Client has received a local_ticket
from the LURK Server and a new_session_ticket from the TLS Server. The
TLS Client updates the  local_ticket as follows:  the ticket_nonce and
extensions fields of the new_session_ticket are copied to the
local_ticket. 

When the TLS Server provides more than one new_session_ticket
tickets, these tickets are expected to have different nonce. On the
other hand a single local_ticket will be provided by the LURK Server.
The TLS Client generates an associated local_ticket for each
new_session_ticket. All of them are generated from the local_ticket
provided by the LURK Server. 

Though the new_Session_ticket and the local_ticket have different
meanings, a TLS Client will not be able to perform session resumption
without the corresponding local_ticket. More specifically, the TLS
Client MUST:

* remove local_tickets and new_session_tickets that have expired
* remove local_tickets that have no associated new_session_tickets
* remove new_session_tickets that have no associated local_tickets
In all these cases, a new handshake will be renegotiated. Note that this
gives the Cryptographic Service the ability to define the maximum time a
new_session_ticket can be used. 


## LURK Server Behavior

Upon receiving a handshake_server_key request, the LURK server proceeds
as follows:

Perfect Forward Secrecy Check is performed as {{hsk-clt}} using the freshness_funct,
and client_random (resp. server_random) as described in {{hsk-clt}}
(resp. {{auth-clt-srv_tls}}).

Transcript-Hash Check, PSKExchangeMode Check,
KeyScheduleInputSecrets Check  are performed as described in {{hsk-srv}}

HandshakeMode Check:

* if the mode is not supported a invalid_handshake_mode error is
returned. This typically prevents a TLS Client to perform computation
expected to happen on the TLS Server, or to distinguish and authorize
client authentication performed during the handshake or post handshake.   

Handshake Check:

* if the hanshake_context does not match the expected handshake context
as defined in {{!RFC8446}} section 4.4. an
invalid_handshake error is returned. 

CertificateVerify Check:

* if ke_mode is set to psk_dhe_ke and the certificate is not supported
 an invalid_certificate error is returned
* if ke_mode is set to psk_dhe_ke and the algorithm is not supported
an invalid_signature_scheme error is returned


Keys are generated as described in {{!RFC8446}}
section 7.1. This includes the Base Key use to generate the Finished
messages as well as the resumption_master_secret.

key_request is indicative and is used by the LURK Client to indicate the
keys that are not necessarily needed in order to save bandwidth. The
LURK Server SHOULD NOT responds with keys whose key_request bit is
unset. 

The CertificateVerify message is generated as described in
{{!RFC8446}} section 4.4.3. 

The Finished message is generated as described in
{{!RFC8446}} section 4.4.4. 

ticket_number indicates the number of NewSessionTicket. ticket_session
have different meaning when used by the TLS Client or the TLS Server.
When the LURK exchange is initiated by the LURK Client, the
ticket_sessions are local_ticket and are only expected to be used
between the LURK Client and the LURK Server. Such local_ticket avoids a
direct communication of the resumption_master_secret.  local_ticket
follows the definition of new_session_tickets described in
{{!RFC8446}} section 4.6.1. The LURK Server MUST have a zero
length ticket_nonce and zero length extensions 

When the LURK exchange is initiated by the TLS Server the tickets are
new_session_tickets as described in {{!RFC8446}} section
4.6.1. As a result:

* if handshake_mode is set to server, the LURK Server SHOULD respond
with a list of new_session_tickets that is not greater than the number
indicated by ticket_number. The number of ticket MAY be defined by the
LURK Server policies. 
* if handshake_mode is set to client or post-handshake the LURK Server
SHOULD respond with a list of local_ticket that is not greater than the
number indicated by ticket_number. The list MUST NOT exceed one
local_ticket.  


# Security Considerations

# IANA Considerations

#  Acknowledgments


# Appendix

This section is non normative. It illustrates the use of LURK in various
configurations.  

The TLS client may propose multiple ways to authenticate the
server (ECDHE, PSK or PSK-ECDHE). The TLS server may chose one of those,
and this choice is reflected by the LURK client on the TLS server. In
other words, this decision is out of scope of the Cryptographic Service. 

The derivation of the secrets is detailed in {{!RFC8446)) section 7.1.
Secrets are derived using Transcript-Hash and HKDF, PSK and ECDHE
secrets as well as some Handshake Context.   

The Hash function:
When PSK or PSK-ECDHE authentication is selected, the Hash function is a
parameter associated to the PSK. When ECDHE, the hash function is
defined by the cipher suite algorithm negotiated. Such algorithm is
defined in the cipher_suite extension provided in the ServerHello which
is provided by the LURK client in the first request when ECDHE
authentication is selected. 

PSK secret:
When PSK or PSK-ECDHE authentication is selected, the PSK is the PSK
value identified by the identity. When ECDHE authentication is selected,
the PSK takes a default value of string of Hash.length bytes set to
zeros.
 

ECDHE secret:
When PSK or PSK-ECDHE authentication is selected, the ECDHE secret takes
the default value of a string of Hash.length bytes set to zeros. The
Hash is always known as a parameter associated to the selected PSK. When
ECDHE authentication is selected, the ECDHE secret is generated from the
secret key (ephemeral_sercet) provided by the LURK client and the
counter part public key in the key_share extension. When the LURK client
is on the TLS client, the public key is provided in the ServerHello.
When the LURK client is on the TLS Server, the public key is provided in
the ClientHello. When ECDHE secret is needed, ClientHello...ServerHello
is always provided to the Cryptographic Service.    

Handshake Context:
is a subset of Handshake messages that are necessary to generated the
requested secrets. The various Handshake Contexts are summarized below:

~~~
+------------------------------------+--------------------------------+
| Key Schedule secret or key         | Handshake Context              |
+---------------------------------------------------------------------+
| binder_key                          | None                          |
| client_early_traffic_secret         | ClientHello                   |
| early_exporter_master_secret        | ClientHello                   |
| client_handshake_traffic_secret     | ClientHello...ServerHello     |
| server_handshake_traffic_secret     | ClientHello...ServerHello     |
| client_application_traffic_secret_0 | ClientHello...server Finished |
| server_application_traffic_secret_0 | ClientHello...server Finished |
| exporter_master_secret              | ClientHello...server Finished |
| resumption_master_secret            | ClientHello...client Finished |
+---------------------------------------------------------------------+
~~~


The Cryptographic Service has always the Hash function, the PSK and
ECDHE secrets and the only remaining parameter is the Handshake Context.
The remaining sections will only focus on checking the Handshake Context
available to the Cryptographic Service is sufficient to perform the key
schedule.  

When ECDHE authentication is selected both for the TLS server or the TLS
client, a CertificateVerify structure is generated as described in
{{!RFC8446}} section 4.4.3.. CertificateVerify consists in a signature
over a context that includes the output of Transcript-Hash(Handshake
Context, Certificate) as well as a context string. Both Handshake
Context and context string depends on the Mode which is set to server in
this case via the configuration of the LURK server. Similarly to the key
schedule, the Hash function is defined by the PSK or the ServerHello.
The values for the Handshake Context are represented below: 

~~~
+-----------+-------------------------+-----------------------------+
| Mode      | Handshake Context       | Base Key                    |
+-----------+-------------------------+-----------------------------+
| Server    | ClientHello ... later   | server_handshake_traffic_   |
|           | of EncryptedExtensions/ | secret                      |
|           | CertificateRequest      |                             |
|           |                         |                             |
| Client    | ClientHello ... later   | client_handshake_traffic_   |
|           | of server               | secret                      |
|           | Finished/EndOfEarlyData |                             |
|           |                         |                             |
| Post-     | ClientHello ... client  | client_application_traffic_ |
| Handshake | Finished +              | secret_N                    |
|           | CertificateRequest      |                             |
+-----------+-------------------------+-----------------------------+
~~~

When ECDHE authentication is selected, the Cryptographic Service
generates a Finished message, which is a MAC over the value
Transcript-Hash(Handshake Context, Certificate, CertificateVerify) using
a MAC key derived from the Base Key. As a result, the same Base Key and
Handshake Context are required for its computation describe din
{{!RFC8466}} section 4.4.4..



## TLS 1.3 Full Handshake with ECDHE authentication only, no TLS client authentication 


This example illustrates the case of a TLS handshake where the TLS
server is authenticated using ECDHE only, that is not PSK or PSK-ECDHE
authentication is provided and so session resumption is not provided
either. 

### TLS Client: ClientHello (#sec:ecdhe-no-resumption-client-hello}

The TLS client does not provides any PSK and  omits the pre_shared_key as
well as the psk_key_exchange_mode extensions. Note that omiting the
psk_key_exchange_mode extension prevents the TLS client to perform
further session resumption. 

The TLS client does not need any interaction with the Cryptographic
Service to generate and send the ClientHello message to the TLS server. 

~~~
TLS Client                                   TLS Server

    Key  ^ ClientHello
    Exch | + key_share
         v + signature_algorithms ---------> 
~~~

### TLS Server: ServerHello  (#sec:ecdhe-no-resumption-server-hello}


Upon receiving the ClientHello, the TLS server determines the TLS client
requests an ECDHE authentication. The TLS server initiates a LURK
session to provide ECDHE authentication as represented below: 

~~~
TLS Client                                   TLS Server

                                             ServerHello  ^ Key
                                             + key_share  | Exch
                                   {EncryptedExtensions}  ^  Server
                                   {CertificateRequest*}  v  Params
                                           {Certificate}  ^
                                     {CertificateVerify}  | Auth
                                              {Finished}  v
                          <--------  [Application Data*]
~~~

The LURK client on the TLS server initiates a schedule context (ks_ctx)
and sends an InitCertificateVerifyRequest to the LURK server. As this is
an initial exchange of a LURK session, the context ID ctx_id is set to
init_id. In our example, key_request sets the handshake and application
secrets. handshake_context is set to ClientHello ... later of server
EncryptedExtensions / CertificateRequest. In our case the TLS server
does not intend to authenticate the TLS server, so handshake_context is
set to ClientHello ... EncryptedExtensions. ephemeral_secret is provided
to generate the ECDHE secret, key_id, sig_algo, serctificate are
provided to generate CertificateVerify. 

~~~
TLS Server                      
Lurk Client                              Cryptographic Service
        InitCertificateVerifyRequest
            ctx_id=init_id
            key_request
            handshake_context
            ephemeral_secret
            key_id, 
            sig_algo 
            certificate               -------->
                                         InitCertificateVerifyResponse
                                            keys, certificate_verify
                                   <---------   finished
~~~

The necessary Handshake Context to generate the handshake secrets are
ClientHello...ServerHello  which are provided by the handshake_context.

The generation of the CertificateVerify is described in {{!RFC8446}}
section 4.4.3. and consists in a signature over a context that includes
the output of Transcript-Hash(Handshake Context, Certificate) as well as
a context string. Both Handshake Context and context string depends on
the Mode which is set to server in this case via the configuration of
the LURK server. 

The necessary Handshake Context to generate the CertificateVerify is
ClientHello ... later of EncryptedExtensions / CertificateRequest. In
our case, this is exactly handshake_context, that is ClientHello ...
EncryptedExtensions.   

Once the certificate_verify value has been defined, the LURK server
generates the server Finished message in order to have the necessary
Handshake Context ClientHello...server Finished to generate the
application secrets. 


The LURK server returns the requested keys, the certificate_verify and
the finished message so the TLS server can complete the ServerHello
response.   

As session resumption is not provided, teh LURK server goes into a
finished state and delete the ks_ctx. 

### TLS client: client Finished (#sec:ecdhe-no-resumption-client-finished}

Upon receiving the ServerHello message, the TLS client retrieve the
handshake and application secrets to decrypt the messages receives from
server as well as to encrypt its own messages and application data as
represented below:

~~~
TLS Client                                   TLS Server

      {Finished}              -------->
      [Application Data]      <------->  [Application Data]
~~~



To retrieves these secrets, the TLS client proceeds successively to an
HandshakeSecretRequest followed by a AppSecretRequest. 

~~~
TLS Client                      
Lurk Client                              Cryptographic Service
        HandshakeSecretRequest
            ctx_id=init_id
            key_request
            handshake_context
            ephemeral_secret
            ------->

                                  HandshakeSecretResponse
                           <--------  keys
TLS Client                      
Lurk Client                              Cryptographic Service
        AppSecretRequest
            ctx_id=opaque
            key_request
            handshake_context
            ephemeral_secret
            ------->

                                  AppSecretResponse
                           <--------  keys
~~~

As the HandshakeSecretRequest initiates a session between the LURK
client and the LURK server, the context ID is set to init_id while next
request have their context ID set to opaque. key_request is set to
handshake secrets only. handshake_context is set to ClientHello ...
ServerHello (with ctx_id of type init_id). ephemeral_secret is provided
to the Cryptographic Service to generate the ECDHE sercet. 

The necessary Handshake to generate handshake secrets is
ClientHello...ServerHello which is provided by the handshake_context. 

Upon receiving the HandshakeSecretRequest with a ctx_id type of init_id,
and no PSK provided, the Cryptographic Service initializes a key
schedule context ks_ctx and computes the handshake_secrets from ECHDE,
PSK, Hash function. Since no client authentication is expected, the
next_request is set to app_secret. It thene return the handshake secrets
to the LURK client. 

The TLS client decrypt the encrypted messages of teh ServerHello
exchange. As no CertificateREquest appears, the LURK client initiates a
AppSecretRequest to decrypt and encrypt application data while finishing
the TLS handshake. key_request is limited to the application secrets.
The handshake_context is set to server EncryptedExtensions ... server
Finished.  

Upon receiving the AppSecretRequest, the Cryptographic Service checks
the request is expected by checking the ctx_id and the request type. The
Cryptographic Service has now the ClientHello ... server Finished which
enables it to compute the application secrets. 

As no session resumption is provided, the Cryptographic Service and the
LURK client goes into a finished state and delete their ks_ctx. 

## TLS 1.3 Full Handshake with ECDHE authentication only and session resumtpion, no TLS client authentication 

This scenario considers that the TLS server is authenticated using ECDHE
only in the first time and that further TLS handshake use the session
resumption mechanism. The first TLS Handshake is very similar as the
previous one. The only difference is that psk_key_exchange_mode
extension is added to the ClientHello. However, as no PSK identity is
provided, the Full exchange is performed as described in section
{{(sec:ecdhe-no-resumption}}.  

The only change is that session resumption is activated, and thus LURK
client and LURK servers do not go in a finished state and close teh LURK
session after the exchanges are completed. Instead further exchanges are
expected. 



### Full Handshake {#sec:ecdhe-session-resumption-fullhandshake}


The Full TLS Handshake use ECDHE authentication. It is very similar rto
the logic described in section {{(sec:ecdhe-no-resumption}}. The TLS
handshake is specified below for convenience. 

~~~
TLS Client                                   TLS Server

    Key  ^ ClientHello
    Exch | + key_share 
         | + psk_key_exchange_mode
         v + signature_algorithms ---------> 
                                             ServerHello  ^ Key
                                             + key_share  | Exch
                                   {EncryptedExtensions}  Server Param
                                           {Certificate}  ^
                                     {CertificateVerify}  | Auth
                                              {Finished}  v
                          <--------  [Application Data*]
      {Finished}              -------->
      [Application Data]      <------->  [Application Data]
~~~

### TLS server: NewSessionTicket {#sec:ecdhe-session-resumption-newsessionticket}

As session resumption has been activated by the psk_key_exchange_mode,
the TLS server does not go into a finished state. Instead, the LURK
client continue the LURK session with a NewSessionTicketRequest to
enable the Cryptographic Service to generate the
resumption_master_secret necessary to generate the PSK and generate a
NewTicketSession. ctx_id is of type opaque, ticket_nbr indicate sthe
number of NewSessionTickets and handshake_context is set to earlier of
client Certificate client CertificateVerify ... client Finished. As we
do not consider TLS client authentication, the handshake_context is set
to client Finished as represented below. 

~~~
TLS Server                      
Lurk Client                              Cryptographic Service
        NewSessionTicketRequest
            ctx_id=ctx_id
            ticket_nbr
            handshake_context=client Finished  -------->
                                         NewSessionTicketResponse
                                   <---------   tickets
~~~

The necessary Handshake Context to generate the resumption_master_secret
is ClientHello...client Finished. From the InitCerificateVerify the
context_handshake was set to ClientHello...server Finished. The
additional handshake_context enables the Cryptographic Service to
generate the NewSessionTickets.  

Note that the LURK client on the TLS server may send multiple
NewSessionTicketRequest. Future request have an emptpy
handshake_context.



It is up to the LURK server implementation to define whether it is in a
finished state or not. If the Cryptographic is in a finished state, it
will not be able to provide NewSessionTickets. If the Cryptographic is
not in a finished state, then the ks_ctx.next_request is set to
NewSessionTicketRequest. The future NewSessionTicketRequest will have
their handshake_context of zero length.  

The TLS server is now able to provide NewSessionTicket and is ready to
accept sesison resumption. 

~~~
TLS Client                                   TLS Server
                          <--------      [NewSessionTicket]
~~~

Similarly, the LURK client on the TLS client will have to provide
sufficient information to the Cryptographic Service the necessary PSK
can be generated in case of session resumption. This includes the
remaining Handshake Context to generate the resumption_master_secret as
well as NewSessionTickets provided by the TLS server. The LURK client
uses the RegisterSessionTicket message. 


Note that the LURK client may provide the handshake_context with an
empty list of NewSessionTickets, and later provide the NewSessionTickets
as they are provided by the TLS server. The Handshake Context only needs
to be provided for the first RegisterSessionTicket. 

~~~
TLS Client                      
Lurk Client                              Cryptographic Service
        NewSessionTicketRequest
            ctx_id=ctx_id
            handshake_context=client Finished  
            ticket_list            -------->
                                         NewSessionTicketResponse
                                   <---------   tickets
~~~


Both TLS client and TLS Servers are ready for further session
resumption. On both side the Cryptographic Service stores the PSK in a
database designated as PSK_DB. Each PSK is associated to a Hash function
as well as authentication modes. Each PSK is designated by an identity.
The identity may be a label, but in our case the identity is derived
from the NewSessionTicket.ticket.    

### Session Resumption

Session resumption is initiated by the TLS client. Session resumption is
based on PSK authentication and different PSK may be proposed by the TLS
client. 


The TLS client may propose to the TLS Server multiple PSK. Each of these
PSK is associated a PskBindersEntry defined in {{!RFC8446}} section
4.2.11.2. PskBindersEntry is computed similarly to the Finished message
using the binder_key and the partial ClientHello. To compute binders,
the TLS Client needs to request the binder_key associated to each
porposed PSK. These binder_keys are retrieved to the Cryptographic
Service using the BinderKeyRequest.

~~~
TLS Client                      
Lurk Client                              Cryptographic Service
        BinderKeyRequest
            ctx_id=init
            key_request=binder_key
            handshake_context=""
                                         BinderKeyResponse
                                   <---------   key
~~~

Upon receiving the BinderKeyRequest, the Cryptographic Service checks
the psk is in the PSK_DB and initiates a key schedule context (ks_ctx).
The derivation of the binder_key is described in {{!RFC8446}} section
7.1. It requires the PSK, and a Hash function. More specifically, no
Handshake Context nor ECDHE secret is needed. PSK is identified by the
PSKIdentity.identity or NewSessionTicket.ticket. The Hash function is
associated to the PSK.  


With the binder keys, the TLS Client is able to send it ClientHello
message. 


~~~
TLS Client                                   TLS Server
       ClientHello
       + key_share*
       + pre_shared_key          -------->
                                                       ServerHello
                                                  + pre_shared_key
                                                      + key_share*
                                             {EncryptedExtensions}
                                                        {Finished}
                                 <--------     [Application Data*]
~~~

As described in {{!RFC8446}} section 4.2.11, the TLS server is expected
to pick a single PSK and validate the binder. In case the binder does
not validate the TLS Handshake is aborted. As a result, only one
binder_key is expected to be requested by the TLS server as opposed to
the TLS client. The binder_key is requested by the TLS server via 
and EarlySecretRequest. In our case, only the binder_key is requested so
key_request is set to binder_key only. Similarly, to the TLS client,
the handshake_context is not need to generate the binder_key. However,
the EarlySecret exchange requires the ClientHello to be provided.  

~~~
TLS Server                      
Lurk Client                              Cryptographic Service
        BinderKeyRequest
            ctx_id=init
            key_request=binder_key
            handshake_context=ClientHello
                                         BinderKeyResponse
                                   <---------   key
~~~

The TLS server validates the binder before proceeding to the
ServerHello. To complete to the ServerHello exchange, the TLS server
needs be able to encrypt the messages with the
server_handshake_traffic_secrets as well as the application data with
the server_application_traffic_secret_0. In addition, The TLS server
will also require the corresponding client_handshake_traffic_secrets and
client_application_traffic_secret_0 to decrypt the client Finished and
associated application data. The procedure is similar as the one
described in the Full
handshake in section {{sec:ecdhe-session-resumption-fullhandshake}}. 
The main differences
are that  CertificateVerify is not requested and that the Handshake
Context has already been initialized with the ClientHello. As a result,
only the complement to the ClientHello is provided. When PSK+ECDHE is
used, the EphemeralSecret is provided. When PSK-only is used, the
EphemeralSecret is empty. The Cryptographic Service checks the
authentication is compatible with the psk_key_exchange_modes. An empty
EphemeralSecret will be replaced by a default value of a string of
Hash.length bytes set to zeros is used. 


~~~
TLS Server                      
Lurk Client                              Cryptographic Service
        HandshakeAndAppRequest
            ctx_id=init_id
            key_request
            handshake_context
            ephemeral_secret          -------->
                                         InitCertificateVerifyResponse
                                            keys, certificate_verify
                                   <---------   finished
~~~

Upon receiving the ServerHello exchange, the TLS client proceeds as
described in section {{sec:ecdhe-session-resumption-fullhandshake}}. 



## TLS Client Authentication (CertificateRequest) 



## TLS Client Authentication (PostHandshake)


## 0-RTT 
























TLS Client                                   TLS Server

                                             ServerHello  ^ Key
                                             + key_share  | Exch
                                   {EncryptedExtensions}  ^  Server
                                   {CertificateRequest*}  v  Params
                                           {Certificate}  ^
                                     {CertificateVerify}  | Auth
                                              {Finished}  v
                          <--------  [Application Data*]
~~~



















Upon receiving the ServerHello, two scenarios may happen:
* The TLS Client does not need to authenticate itself
* The TLS Client needs to authenticate itself in which case
CertificateRequest is present

### No TLS Client  Authentication

Upon receiving the ServerHello, the TLS Client may generate the
necessary keys to decrypt the encrypted ServerHello extensions. Note
that as no PSK is involved, and the Cryptographic is not involved to
ensure the PSK is secret. The TLS Client does not need to involve the
K client on the rvice. 

Alternatively, it may also delegate the computation of the keys to the
Cryptographic Service and perform an LURK Keys exchange. To complete the
handshake, the TLS Client requests server_handshake_traffic_secret,
client_handshake_traffic_secret, server_application_traffic_secret_0,
client_application_traffic_secret_0.

If the TLS Client is not willing to use session resumption, it may
indicate the Cryptographic Service, by setting session_resumption to
false. By doing so, the Cryptographic Service will not keep the context
associated to the key schedule. On the other hand, if the  TLS Client
intends to perform session resumption, it MUST set the
session_resumption to true in order to indicate the Cryptographic
Service that further exchange are expected.  

~~~
TLS Client                      
Lurk Client                              Cryptographic Service
        KeysRequest
            freshness_funct="sha256", h="sha256",
            ke_mode="dhe_ke", key_request=\xf1 
            handshake_context=(ClientHello...server Finished)
            secrets=(ecdhe), session_resumption="true"
            ------->

                                  KeysResponse
                           <--------  keys, context_id
~~~

The TLS Client is able to decrypt the encrypted extensions, verifies the
CertificateVerify signature, the Finished message with the
[server]_handshake_traffic_secret.

The TLS Client computed the Finished message and encrypt it with the
client_handshake_traffic_secret. Similarly, the TLS Client is also able
to decrypt (resp. encrypt) the Application Data with
server_application_traffic_secret_0] (resp.
client_application_traffic_secret_0]). In case the TLS Client needs to
export the master, it also has the exporter_master_secret   


Note that in case of session resumption, the resumption_master_secret is
not provided. One reason is that ClientHello...client Finished needs to
be provided. The other reason is that PSK are not shared outside the
Cryptographic Service. In this case the usage of the Cryptographic
Service is limited as the PSK could have been generated outside the
Cryptographic Service. As a result, the protection provided by the
Cryptographic Service is limited to protect the resumption_master_secret
after the key exchange. 

### TLS Client  Authentication

When the TLS Server requests the TLS Client to authenticate 
with a CertificateRequest, the TLS Client needs to generate a
CertificateVerify. 

Similarly to the TLS Server, the CertificateVerify is requested via a Lurk
AuthRequest. The LURK Client indicates the CertificateVerify is intended
for a TLS Client by setting handshake_mode to "client" as well as by
providing an appropriated Handshake Context that is
ClientHello ... later of server Finished/EndOfEarlyData as well
as the Certificate. 

The Cryptographic returns the certificate_verify as well as the keys. 

~~~
TLS Client
Lurk Client                              Cryptographic Service
        AuthRequest
            freshness_funct="sha256", h="sha256";
            ke_mode="dhe_ke", key_id,
            sig_algo="ed25519", handshake_mode="client",
            handshake_context=(ClientHello ... later of server 
                               Finished/EndOfEarlyData ),
            certificate=Certificate
            secret=(echde), key_request=\xf1,
            session_resumption=true -------->
                                         AuthResponse
                                            keys, certificate_verify
                                   <---------   finished, context_id
~~~

Similarly to {{clt-no-auth}} the TLS Client is able to complete the
TLS Handshake. 

~~~
TLS Client                                   TLS Server

           ^ {Certificate*}
      Auth | {CertificateVerify*}
           v {Finished}              -------->
             [Application Data]      <------->  [Application Data]
~~~



### Session Resumption 

When no PSK is involved, there is always the possibility the PSK be
maintained outside the Cryptographic Service. We assume that when the
Cryptographic Service is involved the key schedule is only performed by
the Cryptographic Service. The Cryptographic Service will maintain a
secure storage of the security credentials to attackers that are not
observing the initial handshake. 

If the TLS Server has not set the session_resumption it will not be able
to generate NewSessionTicket and session resumption will not be
possible. If the TLS Client has not set the session_resumption, it will
not be able to generate the PSK and session resumption will not be
possible either. As a result, session_resumption is only possible when
both TLS Client and TLS Server have set session_resumption in their
previous exchange. 


#### NewSessionTicket to teh (TLS Server)

Providing session resumption is controlled by the TLS Server as it
provides the TLS Client NewSessionTicket. 

The cryptographic Service is responsible for emitting the session
tickets. This will ease the centralization of SessionTicket. 

When a TLS Server is willing to provide session resumption, the TLS
Server is expected to request a NewSessionTicket after the TLS Handshake
is completed - at least during the validity of the context_id.

The TLS Server provides the context_id, the remaining informations to
generate the resumption_master_secret. In this case, the necessary
parameters are the client Finished exchange. In addition, the TLS Server
may specify the number of tickets it is expecting.  

The Cryptographique service knows from the context the request comes
from a TLS Server, completes the key schedule and return a
NewSessionTicket structures. Note that the NewSessionTicket is mostly a
reference (or hint) for the Cryptographic Service to retrieve the PSK
and does not contain information about the PSK. 

~~~
TLS Server
Lurk Client                              Cryptographic Service
        TicketRequest
        context_id, handshake_context=
            (Certificate*,CertificateVerify*,
            Finished), ticket_nbr  -------->
                                         TicketResponse
                                   <---------  new_session_ticket_list
~~~

With the NewSessionTicket, the TLS Server is able to provide the TLS
Client on eor multiple NewSessionTickets.

~~~
TLS Client                                   TLS Server
                          <--------      [NewSessionTicket]
~~~

#### TLS Client 

When the TLS Client decides to perform a session resumption, the TLS
Client indicates in the pre_shared_key extension the PSK used for the
authentication via the ticket mechanism. The pre_share_key extension
associates to each key identity - the ticket field of the
NewSessionTicket structure a binder. Binders are generated imilarly to
the Finished message. Inputs are the KDF
Hash function of the initial handshake, the partial
ClientHello of the current handshake, that is the ClientHello up to and
including the PreSharedKeyExtension.identities field, and the
binder_key. Except the for the binder_key all informations are known to
the TLS Client. 

The binder_key is generated from the PSK, that is the nonce associated
to the identity and the resumption_master_secret. The binder_key is then
requested via the BinderKeyReq exchange. Upon receiving the binder_key,
the TLS Client is able to complete the ClientHello.  

The Cryptographic Service also provides a context_id to reference the
KeyScheduler in future exchanges. 

~~~
TLS Client                      
Lurk Client                              Cryptographic Service
        BinderKeysRequest
            context_id
            handshake=patial ClientHello
            -------->                 BinderKeyResponse
                               <--------- binder_key, context_id
~~~

COMMENT: context_id is similar to NewSessionTicket for the TLS Client.
We need to think of resilient clients.... need some thoughts.

The PSK may be used alone or in combination of the ECHDE, in
which case PFS is provided. The mode has been agreed during the initial
handshake.


COMMENT: session_resumption may be replaced by key_share_mode


~~~
TLS Client                                   TLS Server
          ClientHello
          + key_share*
          + pre_shared_key          -------->
~~~

Upon receiving the ClientHello, the TLS Server, performs a
BinderKeyRequest in order to check the pre_share_keys provided by the
TLS Client. 





~~~
TLS Server                     
Lurk Client                              Cryptographic Service
        BinderKeysRequest
            context_id
            handshake=patial ClientHello
            -------->                 BinderKeyResponse
                               <--------- binder_key, context_id
~~~

The TLS Server is able to build its ServerHello. PSK authentication is
used so no CertificateVErify is needed. The TLS server will request the
various secrets necessary to encrypt/decrypt the TLS Hanshake as well as
Application Data. 

~~~
TLS Server                      
Lurk Client                              Cryptographic Service
        KeysRequest
            freshness_funct="sha256", h="sha256",
            ke_mode="dhe_ke", key_request=\xf1 
            handshake_context=(ClientHello...server Finished)
            secrets=(ecdhe), session_resumption="true"
            ------->

                                  KeysResponse
                           <--------  keys, context_id
~~~

The exchange above we do not have the server Finished and we need it for
the traffic_secret. The exchange below is probably preferred, without
mentioning certificateverify i.e empty certificate. 

~~~
TLS Client
Lurk Client                              Cryptographic Service
        AuthRequest
            freshness_funct="sha256", h="sha256";
            ke_mode="psk_dhe_ke", key_id,
            sig_algo="ed25519", handshake_mode="client",
            handshake_context=(ClientHello ... later of server 
                               Finished/EndOfEarlyData ),
            certificate=""
            secret=(echde), key_request=\xf1,
            session_resumption=true -------->
                                         AuthResponse
                                            keys, certificate_verify
                                   <---------   finished, context_id

~~~

The TLS Server is able to finalize the handshake as described in section
{{}} 


~~~
TLS Client                                   TLS Server
                                                          ServerHello
                                                     + pre_shared_key
                                                         + key_share*
                                                {EncryptedExtensions}
                                                           {Finished}
                                    <--------     [Application Data*]
          {Finished}                -------->
          [Application Data]        <------->      [Application Data]
~~~

Upon receiving the TLS Server ServerHello, the TLS Client proceeds as
describe in {{}}

After the handshake finises, if further session resumption is foreseen,
the TLS Client and TLS Server provide the handshake so the crytpographic
service generates the resumption master_secret.   


PSK associated to ticket:
nonce, context-id, -->PSK




If the TLS Client has set session_resumption to false, it will not
attempt to perform session resumption and will not use the potential
NewSessionTickets provided by the TLS Server. On the other hand, if the
TLS Server 

The remiaing of this section assumes the TLS Server and the TLS Client have set session_resumption
to true. 

COMMENT: We need to understand how ticket and PSK are registered. 
The server has already sent a ticket for session resumption, however,
the resumption_master_secret has not been provided. 


When the TLS Client or the TLS Server wants t


In the case the TLS Server does not
request authentication from the TLS Client, no additional exchange will
be needed. In the case, the TLS Server requests the TLS Client to
authenticate itself with a CertificateRequest extension, the TLS Client
will have to perform an additional AuthRequest.  
    

### Post Handshake Authentication

Handshake_context is set to "post_handshake"


~~~

                             ^ {Certificate*}
                        Auth | {CertificateVerify*}
                             v {Finished}              -------->
                               [Application Data]      <------->  [Application Data]
~~~
      

## TLS 1.3 Full Handshake with PSK-only

## TLS 1.3 Full Handshake with PSK with ECDHE


## TLS 1.3 Full Handshake with PSK

    TLS Client                                                             TLS Server

Lurk Server    Lurk CLient                                                           Lurk Client Lurk Server 


                        Key  ^ ClientHello
                        Exch | + key_share*
                             | + signature_algorithms*
                             | + psk_key_exchange_modes*
                             v + pre_shared_key*       -------->
                                                                          ServerHello  ^ Key
                                                                         + key_share*  | Exch
                                                                    + pre_shared_key*  v
                                                                {EncryptedExtensions}  ^  Server
                                                                {CertificateRequest*}  v  Params
                                                                       {Certificate*}  ^
                                                                 {CertificateVerify*}  | Auth
                                                                           {Finished}  v
                                                       <--------  [Application Data*]
                             ^ {Certificate*}
                        Auth | {CertificateVerify*}
                             v {Finished}              -------->
                               [Application Data]      <------->  [Application Data]

